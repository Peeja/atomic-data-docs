<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Relation to RDF - Atomic Data</title>
        
        


        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Documentation for the Atomic Data standard.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../atomic-data-overview.html"><strong aria-hidden="true">1.</strong> Atomic Data Overview</a></li><li class="chapter-item expanded "><a href="../core/intro.html"><strong aria-hidden="true">2.</strong> Atomic Data Core</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../core/concepts.html"><strong aria-hidden="true">2.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="../core/serialization.html"><strong aria-hidden="true">2.2.</strong> Serialization</a></li><li class="chapter-item expanded "><a href="../core/querying.html"><strong aria-hidden="true">2.3.</strong> Querying</a></li></ol></li><li class="chapter-item expanded "><a href="../schema/intro.html"><strong aria-hidden="true">3.</strong> Atomic Schema</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../schema/classes.html"><strong aria-hidden="true">3.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="../schema/datatypes.html"><strong aria-hidden="true">3.2.</strong> Datatypes</a></li><li class="chapter-item expanded "><a href="../schema/translations.html"><strong aria-hidden="true">3.3.</strong> Translations</a></li><li class="chapter-item expanded "><a href="../schema/faq.html"><strong aria-hidden="true">3.4.</strong> FAQ</a></li></ol></li><li class="chapter-item expanded "><a href="../mutations/intro.html"><strong aria-hidden="true">4.</strong> Atomic Mutations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../mutations/concepts.html"><strong aria-hidden="true">4.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="../mutations/suggestions.html"><strong aria-hidden="true">4.2.</strong> Suggestions</a></li><li class="chapter-item expanded "><a href="../mutations/versioning.html"><strong aria-hidden="true">4.3.</strong> Versioning</a></li></ol></li><li class="chapter-item expanded "><a href="../interoperability/intro.html"><strong aria-hidden="true">5.</strong> Interoperability</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../interoperability/rdf.html" class="active"><strong aria-hidden="true">5.1.</strong> Relation to RDF</a></li><li class="chapter-item expanded "><a href="../interoperability/json.html"><strong aria-hidden="true">5.2.</strong> Relation to JSON</a></li><li class="chapter-item expanded "><a href="../interoperability/ipfs.html"><strong aria-hidden="true">5.3.</strong> Relation to IPFS</a></li></ol></li><li class="chapter-item expanded "><a href="../core/validations.html"><strong aria-hidden="true">6.</strong> Types of Graph Validations</a></li><li class="chapter-item expanded "><a href="../tooling.html"><strong aria-hidden="true">7.</strong> Tooling</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="../get-involved.html">Get involved</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Atomic Data</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/ontola/atomic-data" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#how-does-atomic-data-relate-to-rdf" id="how-does-atomic-data-relate-to-rdf">How does Atomic Data relate to RDF?</a></h1>
<p>RDF is the original data model behind linked data.
It is also the forerunner of Atomic Data, and is therefore highly similar in its philosophy and model.
Both heavily rely on using URLs, and both have a fundamentally simple and uniform model for data statements.
Both view the web as a single, connected graph database.
Because of that, Atomic Data is also highly compatible with RDF - <strong>all Atomic Data can be converted into valid RDF</strong>.
Atomic Data can be thought of as a <strong>more constrained, type safe version of RDF</strong>.
However, it does differ in some fundamental ways.</p>
<ul>
<li>Atomic calls the three parts of a Triple <code>subject</code>, <code>property</code> and <code>value</code>, instead of <code>subject</code>, <code>predicate</code>, <code>object</code>.</li>
<li>Atomic does not support having multiple statements with the same <code>&lt;subject&gt; &lt;predicate&gt;</code>, every combination should be unique.</li>
<li>Atomic has no difference between <code>literal</code>, <code>named node</code> and <code>blank node</code> objects - these are all <code>values</code>, but with different datatypes.</li>
<li>Atomic does not support <code>blank nodes</code>.</li>
<li>Atomic requires URL (not URI) values in its <code>subjects</code> and <code>predicates</code> (properties), which means that they should be resolvable.</li>
<li>Atomic only allows those who control a resource's <code>subject</code> URL endpoint to edit the data. This means that you can't add triples about something that you don't control.</li>
<li>Atomic has no separate <code>datatype</code> field, but it requires that <code>Properties</code> (the resources that are shown when you follow a <code>predicate</code> value) specify a datatype</li>
<li>Atomic has no separate <code>language</code> field, but it does support <a href="../schema/translations.html">Translation Resources</a>.</li>
<li>Atomic has a native Event (state changes) model (<a href="../mutations/intro.html">Atomic Mutations</a>), which enables communication of state changes</li>
<li>Atomic has a native Schema model (<a href="../schema/intro.html">Atomic Schema</a>), which helps developers to know what data types they can expect (string, integer, link, array)</li>
<li>Atomic does not support <code>graph</code> fields in statements.</li>
</ul>
<h2><a class="header" href="#why-these-changes" id="why-these-changes">Why these changes?</a></h2>
<p>I love RDF, and have been working with it for quite some time now.
Using URIs (and more-so URLs, which are URIs that can be fetched) for everything is a great idea, since it helps with interoperability and enables truly decentralized knowledge graphs.
However, some of the characteristics of RDF might have contributed to its relative lack of adoption.</p>
<p>As a developer who uses RDF data, I want to be able to do something like this:</p>
<pre><code class="language-js">const joep = get(&quot;https://example.com/person/joep&quot;)

// Fetches the employer relation at possibly some other domain, checks that resource for a property with the 'name' shortkey
console.log(joep.employer().name()) // =&gt; &quot;Ontola.io&quot;
</code></pre>
<p>To do this, we need a couple of things:</p>
<ul>
<li>Traverse data on various domains (which is already possible with RDF)</li>
<li>Map properties to keys</li>
<li>Have typed properties</li>
<li>Have unique <code>subject-predicate</code> combinations</li>
</ul>
<h3><a class="header" href="#selecting-rdf-values-is-difficult" id="selecting-rdf-values-is-difficult">Selecting RDF values is difficult</a></h3>
<p>One of the main reasons for making changes to RDF, has to do with how hard it is to identify a specific value (<code>object</code>) in RDF.
For example, let's say I want to render someone's birthday.
The triple containing that birthday may exist in some named graph, which means I first need to target that graph.
Then I need to know how to get access to that graph - hopefully by fetching its URL.
Then, I need to make sure that I have one triple - not multiple.
Then, I need to make sure that the datatype is actually the type that I need (e.g. an ISO DateTime).</p>
<h3><a class="header" href="#changing-the-names" id="changing-the-names">Changing the names</a></h3>
<p>RDF's <code>subject</code>, <code>predicate</code> and <code>object</code> terminology can be confusing to newcomers, so Atomic Data uses <code>subject</code>, <code>property</code>, <code>value</code>.
This more closely resembles common CS terminology. (<a href="https://github.com/ontola/atomic-data/issues/3">discussion</a>)</p>
<h2><a class="header" href="#subject--predicate-uniqueness" id="subject--predicate-uniqueness">Subject + Predicate uniqueness</a></h2>
<p>In RDF, it's very much possible for a graph to contain multiple statements that share both a <code>subject</code> and a <code>predicate</code>.
One of the reasons this is possible, is because RDF graphs should always be mergeable.
However, this introduces some extra complexity for data users.
Whereas most languages and datatypes have <code>key-value</code> uniqueness that allow for unambiguous value selection, RDF clients have to deal with the possibility that multiple triples with the same <code>subject-predicate</code> combination might exist.</p>
<p>Atomic Data requires <code>subject-property</code> uniqueness, which means that this is no longer an issue for clients.
However, in order to guarantee this, and still retain <em>graph merge-ability</em> we also need to limit who creates statements about a subject.</p>
<h3><a class="header" href="#limiting-subject-usage" id="limiting-subject-usage">Limiting subject usage</a></h3>
<p>RDF allows that <code>anne.com</code> creates and hosts statements about the subject <code>john.com</code>. In other words, domain A creates statements about domain B. This means that someone using RDF data about domain B cannot know that domain B is actually the source of the data. Knowing <em>where data comes from</em> is one of the great things about URIs, but RDF does not require that you can think of subjects as the source of data. Many subjects in RDF don't actually resolve to all the known triples of the statement. It would make the conceptual model way simpler if statements about a subject could only be made from the source of the domain owner of the subject.</p>
<h3><a class="header" href="#no-more-literals--named-nodes" id="no-more-literals--named-nodes">No more literals / named nodes</a></h3>
<p>In RDF, an <code>object</code> can either be a <code>named node</code>, <code>blank node</code> or <code>literal</code>. A <code>literal</code> has a <code>value</code>, a <code>datatype</code> and an optional <code>language</code> (if the <code>literal</code> is a string).
Although RDF statements are often called <code>triples</code>, a single statement can consist of five fields: <code>subject</code>, <code>predicate</code>, <code>object</code>, <code>language</code>, <code>datatype</code>.
Having five fields is way more than most information systems. Usually we have just <code>key</code> and <code>value</code>.
This difference leads to compatibility issues when using RDF in applications.
In practice, clients have to run a lot of checks before they can use the data - which makes RDF in most contexts harder to use than something such as JSON.</p>
<p>Atomic Data drops the <code>named node</code> / <code>literal</code> distinction.
We just have <code>values</code>, and they are interpreted by looking at the <code>datatype</code>, which is defined in the <code>property</code>.
When a value is a URL, we don't call it a named node, but we simply use a URL datatype.</p>
<h3><a class="header" href="#requiring-urls" id="requiring-urls">Requiring URLs</a></h3>
<p>RDF allows any type of URIs for <code>subject</code> and <code>predicate</code> value, which means they can be URLs, but don't have to be. This means they don't always resolve, or even function as locators. The links don't work, and that restricts how useful the links are. Atomic Data takes a different approach: these links MUST Resolve. Requiring Properties to resolve is part of what enables the type system of Atomic Schema - they provide the <code>shortname</code> and <code>datatype</code>.</p>
<p>Requiring URLs makes things easier for data users, at the cost of the data producer.
With Atomic Data, the data producer MUST offer the triples at the URL of the subject.
This is a challenge - especially with the current (lack of) tooling.</p>
<p>However - making sure that links <em>actually work</em> offer tremendous benefits for data consumers, and that advantage is often worth the extra trouble.</p>
<h3><a class="header" href="#no-more-blank-nodes" id="no-more-blank-nodes">No more blank nodes</a></h3>
<p>RDF allows <code>blank nodes</code> (resources with identifiers that exist only locally), Atomic Data does not.
They make things easier for content providers, but make things <a href="http://richard.cyganiak.de/blog/2011/03/blank-nodes-considered-harmful/">harder for content consumers</a>.
They severely limit how client systems can store data, as name collisions with blank nodes are possible and cache invalidation is hard (or impossible) with blank nodes.</p>
<p>Blank nodes make a lot of sense in hand-written RDF (e.g. Turtle) files.
However, that argument doesn't hold for systems that create the identifiers for you.
Although data creators <em>should</em> have means to specify URLs for certain resources, they <em>should not</em> have to specify every single one.
Ideally, the interface that you use as a data producer will create (persistent, resolvable) identifiers when you create the resources.</p>
<h3><a class="header" href="#combining-datatype-and-predicate" id="combining-datatype-and-predicate">Combining datatype and predicate</a></h3>
<p>Having both a <code>datatype</code> and a <code>predicate</code> value can lead to confusing situations.
For example, the <a href="https://schema.org/dateCreated"><code>schema:dateCreated</code></a> Property requires an ISO DateTime string (according to the schema.org definition), but using a value <code>true</code> with an <code>xsd:boolean</code> datatype results in perfectly valid RDF.
This means that client software using triples with a <code>schema:dateCreated</code> predicate cannot safely assume that its value will be a DateTime.
So if the client wants to use <code>schema:dateCreated</code> values, the client must also specify which type of data it expects, check the datatype field of every Atom and provide logic for when these don't match.
Also important combining <code>datatype</code> and <code>predicate</code> fits the model of most programmers and langauges better - just look at how every single struct / model / class / shape is defined in programming languages: <code>key: datatype</code>.
This is why Atomic Data requires that a <code>predicate</code> links to a Property which must have a <code>Datatype</code>.</p>
<h3><a class="header" href="#adding-shortnames-slugs--keys-in-properties" id="adding-shortnames-slugs--keys-in-properties">Adding shortnames (slugs / keys) in Properties</a></h3>
<p>Using full URI strings as keys (in RDF <code>predicates</code>) results in a relatively clunky Developer Experience. Consider the short strings that developers are used to in pretty much all languages and data formats (<code>object.attribute</code>). Adding a <em>required</em> / tightly integrated key mapping (from long URLs to short, simple strings) in Atomic Properties solves this issue, and provides developers a way to write code like this: <code>someAtomicPerson.bestFriend.name =&gt; &quot;Britta&quot;</code>. Although the RDF ecosystem does have some solutions for this (@context objects in JSON-LD, @prefix mappings, the @ontologies library), these prefixes are not defined in Properties themselves and therefore are defined locally only, which means that developers have to manually map them most of the time. This is why Atomic Data introduces a <code>shortname</code> field in Properties, which forces modelers to choose a 'key' that can be used in ORM contexts.</p>
<h3><a class="header" href="#adding-native-arrays" id="adding-native-arrays">Adding native arrays</a></h3>
<p>RDF lacks a clear solution for dealing with <a href="https://ontola.io/blog/ordered-data-in-rdf/">ordered data</a>, resulting in confusion when developers have to create lists of content.
Adding an Array data type as a base data type helps solve this. (<a href="https://github.com/ontola/atomic-data/issues/4">discussion</a>)</p>
<h3><a class="header" href="#adding-a-native-mutation-standard" id="adding-a-native-mutation-standard">Adding a native mutation standard</a></h3>
<p>There is no integrated standard for communicating state changes.
Although <a href="https://github.com/ontola/linked-delta">linked-delta</a> and <a href="https://afs.github.io/rdf-delta/">rdf-delta</a> do exist, they aren't referred to by the RDF spec.
I think developers need guidance when learning a new system such as RDF, and that's why <a href="../mutations/intro.html">Atomic Mutations</a> is included in this book.</p>
<h3><a class="header" href="#adding-a-schema-language" id="adding-a-schema-language">Adding a schema language</a></h3>
<p>Validating RDF graphs is hard. Validating both the <em>shape</em> (whether required fields are present) of RDF data, as well as its <em>authenticity</em> (whether we can trust the individual Statements) is complex. Shape validations are possible using both <a href="https://www.w3.org/TR/shacl/">SHACL</a> and <a href="https://shex.io/">SHEX</a>, and they are both very powerful and well designed.</p>
<h3><a class="header" href="#a-new-name-with-new-docs" id="a-new-name-with-new-docs">A new name, with new docs</a></h3>
<p>Besides the technical reasons described above, I think that there are social reasons to start with a new concept and give it a new name:</p>
<ul>
<li>The RDF vocabulary is intimidating. When trying to understand RDF, you're likely to traverse many pages with new concepts: <code>literal</code>, <code>named node</code>, <code>graph</code>, <code>predicate</code>, <code>named graph</code>, <code>blank node</code>... The core specification provides a formal description of these concepts, but fails to do this in a way that results in quick understanding and workable intuitions. Even experienced RDF developers tend to be confused about the nuances of the core model.</li>
<li>There is a lack of learning resources that provide a clear, complete answer to the lifecycle of RDF data: modeling data, making data, hosting it, fetching it, updating it. Atomic Data aims to provide an opinionated answer to all of these steps. It feels more like a one-stop-shop for questions that developers are likely to encounter, whilst keeping the extendability.</li>
<li>All Core / Schema URLs should resolve to simple, clear explanations with both examples and machine readable definitions. Especially the Property and Class concepts.</li>
<li>The Semantic Web community has had a lot of academic attention from formal logic departments, resulting in a highly developed standard for knowledge modeling: the Web Ontology Language (OWL). While this is mostly great, its open-world philosophy and focus on reasoning abilities can confuse developers who are simply looking for a simple way to share models in RDF.</li>
</ul>
<!-- - Re-using predicate URIs in new contexts can be result in unclear descriptions, since the meaning of predicates can be very class-dependent. For example, a `name` for a Person means something else than a `name` for a  -->
<h2><a class="header" href="#convert-rdf-to-atomic-data" id="convert-rdf-to-atomic-data">Convert RDF to Atomic Data</a></h2>
<ul>
<li><strong>All the <code>subject</code> URLs MUST actually resolve, and return all triples about that subject</strong>. All <code>blank nodes</code> should be converted into URLs. Atomic Data tools might help to achieve this, for example by hosting the data.</li>
<li><strong>All <code>predicates</code> SHOULD resolve to Atomic Properties, and these SHOULD have a <code>datatype</code></strong>. You will probably need to change predicate URLs to Atomic Property URLs, or update the things that the predicate points to to include the required Atomic Property items (e.g. having a Datatype and a Shortname). This also means that the <code>datatype</code> in the original RDF statement can be dropped.</li>
<li>Literals with a <code>language</code> tag are converted to TranslationBox resources, which also means their identifiers must be created. Keep in mind that Atomic Data does not allow for blank nodes, so the TranslationBox identifiers must be URLs.</li>
</ul>
<p>Step by step, it entails:</p>
<ol>
<li>Set up some server to make sure the URLs will resolve.</li>
<li>Create (or find and refer to) Atomic Properties for all the <code>predicates</code>. Make sure they have a DataType and a Shortname.</li>
<li>If you have triples about a subject that you don't control, change the URL to some that you <em>can</em> control, and refer to that external resource.</li>
</ol>
<p>Atomic Data will need <a href="../tooling.html">tooling</a> to facilitate in this process.
This tooling should help to create URLs, Properties, and host everything on an easy to use server.</p>
<h2><a class="header" href="#convert-atomic-data-to-rdf" id="convert-atomic-data-to-rdf">Convert Atomic data to RDF</a></h2>
<p>Since all Atomic Data is also valid RDF, it's trivial to convert / serialize Atoms to RDF.
However, contrary to Atomic Data, RDF has optional Language and Datatype elements in every statement.
It is good practice to use these RDF concepts when serializing Atomic Data into Turtle / RDF/XML, or other <a href="https://ontola.io/blog/rdf-serialization-formats/">RDF serialization formats</a>.</p>
<ul>
<li>Convert Atoms with linked <code>TranslationBox</code> Resources to Literals with an <code>xsd:string</code> datatype and the corresponding language in the tag.</li>
<li>Dereference the Property and Datatype from Atomic Properties, and add the URLs in <code>datatypes</code> in RDF statements.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../interoperability/intro.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../interoperability/json.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../interoperability/intro.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../interoperability/json.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-121994595-2', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
