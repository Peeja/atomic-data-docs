<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Atomic Data</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Documentation for the Atomic Data standard.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="atomic-data-overview.html"><strong aria-hidden="true">1.</strong> Atomic Data Overview</a></li><li class="chapter-item expanded "><a href="core/intro.html"><strong aria-hidden="true">2.</strong> Atomic Data Core</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="core/concepts.html"><strong aria-hidden="true">2.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="core/serialization.html"><strong aria-hidden="true">2.2.</strong> Serialization</a></li><li class="chapter-item expanded "><a href="core/querying.html"><strong aria-hidden="true">2.3.</strong> Querying</a></li></ol></li><li class="chapter-item expanded "><a href="schema/intro.html"><strong aria-hidden="true">3.</strong> Atomic Schema</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="schema/classes.html"><strong aria-hidden="true">3.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="schema/datatypes.html"><strong aria-hidden="true">3.2.</strong> Datatypes</a></li><li class="chapter-item expanded "><a href="schema/faq.html"><strong aria-hidden="true">3.3.</strong> FAQ</a></li></ol></li><li class="chapter-item expanded "><a href="mutations/intro.html"><strong aria-hidden="true">4.</strong> Atomic Mutations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="mutations/concepts.html"><strong aria-hidden="true">4.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="mutations/suggestions.html"><strong aria-hidden="true">4.2.</strong> Suggestions</a></li><li class="chapter-item expanded "><a href="mutations/versioning.html"><strong aria-hidden="true">4.3.</strong> Versioning</a></li></ol></li><li class="chapter-item expanded "><a href="interoperability/intro.html"><strong aria-hidden="true">5.</strong> Interoperability</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="interoperability/ipfs.html"><strong aria-hidden="true">5.1.</strong> Relation to IPFS</a></li><li class="chapter-item expanded "><a href="interoperability/rdf.html"><strong aria-hidden="true">5.2.</strong> Relation to RDF</a></li><li class="chapter-item expanded "><a href="interoperability/json.html"><strong aria-hidden="true">5.3.</strong> Relation to JSON</a></li></ol></li><li class="chapter-item expanded "><a href="core/graphs.html"><strong aria-hidden="true">6.</strong> Types of Atomic Graphs</a></li><li class="chapter-item expanded "><a href="tooling.html"><strong aria-hidden="true">7.</strong> Tooling</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="get-involved.html">Get involved</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Atomic Data</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/ontola/atomic-data" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#atomic-data-overview" id="atomic-data-overview">Atomic Data Overview</a></h1>
<p><em>Status: early draft, far from usable. <a href="get-involved.html">Feedback welcome</a>.</em></p>
<p>Atomic Data is a propsed standard for modelling and exchanging data.
It uses links to connect pieces of data, and therefore makes it easier to connect datasets to each other - even when these datasets exist on seperate machines.
Atomic Data is heavily inspired by <a href="https://ontola.io/what-is-linked-data/">Linked Data</a>, and can be thought of as a more strict subset of RDF.
Atomic Data is typed (you know if something is a <code>string</code>, <code>number</code>, <code>URL</code>, etc.) and extensible through <a href="schema/intro.html">Atomic Schema</a>, which means that you can define your own Classes, Properties and Datatypes.
Atomic Data has a standard for synchronizing data by communicating state changes, called <a href="mutations/intro.html">Atomic Mutations</a>.
You can use parts of Atomic Data separately, but the standard is designed as a full data management package that makes it easier to create, share and use structured data on the web.</p>
<ul>
<li><a href="core/intro.html">Atomic Data Core</a>: the core model for typed, Linked Data</li>
<li><a href="schema/intro.html">Atomic Schema</a>: defining properties, datatypes and classes</li>
<li><a href="mutations/intro.html">Atomic Mutations</a>: sharing state changes, verifying changes and collaboration</li>
</ul>
<h1><a class="header" href="#atomic-data-core" id="atomic-data-core">Atomic Data Core</a></h1>
<p>The Atomic Data Core describes the fundamental data model of Atomic Data.
Before we dive into its concepts, we'll talk about why this standard is made in the first place.</p>
<h2><a class="header" href="#design-goals" id="design-goals">Design goals</a></h2>
<ul>
<li><strong>Browseable</strong>: Data should explicitly link to other pieces of data, and these links should be followable.</li>
<li><strong>Semantic</strong>: Every data Atom and relation has a clear semantic meaning.</li>
<li><strong>Open</strong>: Free to use, open source, no strings attached.</li>
<li><strong>Clear Ownership</strong>: The URL of the data shows who is in control of the data.</li>
<li><strong>Mergeable</strong>: Any two sets of Atoms can be merged into a sinlge graph without any merge conflicts / name collissions.</li>
<li><strong>Interoperable</strong>: Can easily and consitently be converted to other data formats (e.g. JSON, XML, and all RDF formats).</li>
<li><strong>Extensible</strong>: Anyone can define their own data types and create Atoms with it.</li>
<li><strong>ORM-friendly</strong>: Navigate a <em>decentralized</em> graph by using dot.syntax, similar to how you navigate a JSON object in javascript.</li>
<li><strong>Typed</strong>: All valid Atomic data has an unambiguous, static datatype. Models expressed in Atomic Data can be mapped to programming language models, such as <code>structs</code> or <code>interfaces</code> in Typescript / Rust / Go.</li>
</ul>
<p>Note that for these last four goals, <a href="core/../schema/intro.html">Atomic Schema</a> is required.</p>
<h2><a class="header" href="#motivation" id="motivation">Motivation</a></h2>
<p>Linked data (RDF / the semantic web) enables us to use the web as a large, decentralized graph database.
Using links everywhere in data has amazing merits: links remove ambiguity, they enable exploration, they enable connected datasets.
However, it's been almost 20 years since the introduction of linked data, and its adoption has been slow.
We believe this lack of growth has to do with <a href="core/../interoperability/rdf.html#why-these-changes">some problems that lie in the RDF data model</a>.
Atomic Data aims to take the best parts from RDF, and learn from the past to make a more developer-friendly, performant and reliable data model to achieve a truly linked web.</p>
<h1><a class="header" href="#atomic-data-core-concepts" id="atomic-data-core-concepts">Atomic Data Core: Concepts</a></h1>
<p>Understanding the Core concepts of Atomic Data are fundamental for reading the rest of the documentation.</p>
<h2><a class="header" href="#atomic-data" id="atomic-data">Atomic Data</a></h2>
<p>Atomic Data is a data format for representing information on the web.
It is a directed, labeled graph, similar to RDF.
It can be used to express any type of information, inlcuding personal data, vocabularies, metadata, documents, files and more.
Contrary to some other (labeled) graph data models, a relationship between two items (Resources) does not have attributes.</p>
<h2><a class="header" href="#atom-or-atomic-triple" id="atom-or-atomic-triple">Atom (or Atomic Triple)</a></h2>
<p>The smallest possible piece of <em>meaningful</em> data / information.
The model of an Atom is comparable with an RDF Triple / Statement (<a href="core/../interoperability/rdf.html">although there are imporant differences</a>).
An Atom consists of three values:</p>
<ul>
<li><strong><a href="core/concepts.html#subject">Subject</a></strong>: the Thing that the atom is providing information about.</li>
<li><strong><a href="core/concepts.html#property">Property</a></strong>: the property of the Thing that the atom is about (will always be a URL to a <a href="core/../schema/classes.html#property">Property</a>).</li>
<li><strong><a href="core/concepts.html#value">Value</a></strong>: the new piece of information about the Atom.</li>
</ul>
<p>Let's turn this sentence into Atoms:</p>
<p><code>Arnold, who's born on the 20th of Januari 1991, has a best friend named Britta.</code></p>
<pre><code class="language-ad3">[&quot;https://example.com/arnold&quot;,&quot;https://example.com/properties/bornAt&quot;,&quot;1991-01-20&quot;]
[&quot;https://example.com/arnold&quot;,&quot;https://example.com/properties/firstName&quot;,&quot;Arnold&quot;]
[&quot;https://example.com/arnold&quot;,&quot;https://example.com/properties/bestFriend&quot;,&quot;https://example.com/britta&quot;]
[&quot;https://example.com/britta&quot;,&quot;https://example.com/properties/firstName&quot;,&quot;Britta&quot;]
</code></pre>
<p>In the Atomic Data above, we have:</p>
<ul>
<li>four different Atoms (every line is an Atom)</li>
<li>two different Subjects: <code>https://example.com/arnold</code> and <code>https://example.com/britta</code>.</li>
<li>three different Properties (<code>https://example.com/properties/bornAt</code>, <code>https://example.com/properties/firstName</code>, and <code>https://example.com/properties/bestFriend</code>)</li>
<li>four different Values (<code>1991-0-20</code>, <code>Arnold</code>, <code>https://example.com/britta</code> and <code>Britta</code>)</li>
</ul>
<p>All Subjects and Properties are URLs, they are links that can be retrieved.
One of the Values is a URL, too, but what are the others?
Their Datatypes are defined by the Properties.
For example, the <code>https://example.com/properties/bornAt</code> Property requires an ISO Date string, and the <code>https://example.com/properties/firstName</code> Property requires a regular string.</p>
<h2><a class="header" href="#subject" id="subject">Subject</a></h2>
<p>The Subject field is the first part of an Atom.
It is the identifier that the rest of the Atom is providing information about.
It's a URL that points to the Resource.
The creator of the Subject MUST make sure that it resolves.
In other words: following / downloading the Subject link will provide you with all the Atoms about the Subject (see <a href="core/querying.html">Atomic Querying</a>.</p>
<h2><a class="header" href="#property" id="property">Property</a></h2>
<p>The Property field is the second part of an Atom.
In RDF, this is called a <code>predicate</code>.
It is a URL that points to an Atomic <a href="core/../schema/classes.html#Property">Property</a>.
For example <code>https://example.com/createdAt</code> or <code>https://example.com/firstName</code>.</p>
<!-- Making this a requirement is what makes Atomic Data typed and semantic -->
<p>The Property field MUST be a URL, and that URL MUST resolve to an Atomic Property, which contains information about the Datatype.</p>
<h2><a class="header" href="#value" id="value">Value</a></h2>
<p>The Value field is the third part of an Atom.
In RDF, this is called an <code>object</code>.
Contrary to the Subject and Property values, the Value can be of any datatype.
This includes URLs, strings, integers, dates and more.</p>
<h2><a class="header" href="#graph" id="graph">Graph</a></h2>
<p>A Graph is a set of Atoms.
A Graph can describe various subjects, and may or may not be related.
Graphs can have several characteristics (Schema Complete, Valid, Closed)</p>
<h2><a class="header" href="#resource" id="resource">Resource</a></h2>
<p>A Resource is a set of Atoms (a Graph) that share the same Subject URL.
Every thing is Resource, such as the person &quot;Michael Jackson&quot;, or the abstract class &quot;Person&quot;.
All the concepts on this page are Resources.
A</p>
<p>Properties:</p>
<ul>
<li><code>a</code> - (optional, AtomicURL) the <a href="core/../schema/classes.html#class">Class</a> of the Resource.</li>
</ul>
<h1><a class="header" href="#serialization-of-atomic-data" id="serialization-of-atomic-data">Serialization of Atomic Data</a></h1>
<p>Atomic Data is not necessarily bound to a single serialization format.
It's fundamentally a data model, and that's an important distinction to make.
We recommend you use <code>AtomicTriples</code>, which is specifically designed to be a simple, performant format for Atomic Data.</p>
<h2><a class="header" href="#atomictriples-ndjson-ad3" id="atomictriples-ndjson-ad3">AtomicTriples-ndjson (.ad3)</a></h2>
<p>Since the data model of Atomic Data is a bit simpler than RDF, serialization and parsing can be simpler as well.
In fact, a single Atom can be represented by an array of three strings, respectively representing the Subject, Property and Value.</p>
<p>It looks like this:</p>
<pre><code class="language-ndjson">[&quot;https://example.com/subject&quot;,&quot;https://example.com/property&quot;,&quot;some object&quot;]
[&quot;https://example.com/subject&quot;,&quot;https://example.com/otherProperty&quot;,&quot;https://example.com/somethingelse&quot;]
</code></pre>
<p>We use Newline Delimited JSON (<a href="http://ndjson.org/">NDJSON</a>), which is just a large JSONG string with newlines between each object.</p>
<p>NDJSON has some important benefits:</p>
<ul>
<li>It visually represents the underlying datamodel (the Atom)</li>
<li>It can be streaming parsed, i.e. before the entire document is loaded. That is not possible with regular JSON.</li>
<li>NDJSON parsers are everywhere</li>
<li>Modern browers have highly performant JSON parsing, which means that it's <em>fast</em> in one of the most imporant contexts: the browser.</li>
</ul>
<p><em>Mime type (not registered yet!): <code>application/ad3-ndjson</code></em></p>
<p><em>File name extention: <code>.ad3</code></em></p>
<p>Disclaimer: note that Atomic-NDJSON is useful for communicating <em>current state</em>, but not for <em>state changes</em>.</p>
<h2><a class="header" href="#atomicdoubles-ndjson-ad2" id="atomicdoubles-ndjson-ad2">AtomicDoubles-ndjson (.ad2)</a></h2>
<p>AtomicDoubles is similar to AtomicTriples, with one exception: the Subject is left out.
For many usecases, omitting the Subject is a <em>bad idea</em>.</p>
<p>However, it can be useful in (at least) two scenarios:</p>
<ul>
<li>The <strong>Subject is not yet known</strong> (for example, because it still has to be determined by some server or hash function).</li>
<li>The <strong>Subject is already known by the client</strong>, and leaving it out saves bandwith. This happens for example during Subject Fetching, where the request itself contains the Subject, because the fetched URL itself is the Subject of all returned triples. Note that in this scenario, the server is unable to include</li>
</ul>
<pre><code class="language-ndjson">[&quot;https://example.com/property&quot;,&quot;some object&quot;]
[&quot;https://example.com/otherProperty&quot;,&quot;https://example.com/somethingelse&quot;]
</code></pre>
<p>This format is <strong>not suitable for persistent storage</strong> or peer to peer sharing - it is only useful when</p>
<ul>
<li><em>Mime type (not registered yet!): <code>application/ad2-ndjson</code></em></li>
<li><em>File name extention: <code>.ad2</code></em></li>
</ul>
<h2><a class="header" href="#rdf-serializatinon-formats" id="rdf-serializatinon-formats">RDF serializatinon formats</a></h2>
<p>Because of the similarties with RDF, RDF serialization formats can be used to communicate and store Atomic Data, such as N-Triples, Turtle, HexTuples or JSON-LD.
<em>However</em>, keep in mind that RDF users will expect other things from their data.
Read more about the various existing formats and their respective merits <a href="https://ontola.io/blog/rdf-serialization-formats/">here</a>.</p>
<h2><a class="header" href="#future-formats" id="future-formats">Future formats</a></h2>
<p>In the future, new serialization formats will be introduced.
For example, a fully optimized binary serialization format would make sense.</p>
<h1><a class="header" href="#querying-atomic-data" id="querying-atomic-data">Querying Atomic Data</a></h1>
<p>There are multiple ways of getting Atomic Data into some system:</p>
<ul>
<li><a href="core/querying.html#subject-fetching-http"><strong>Subject Fetching</strong></a> requests a single subject right from its source</li>
<li><a href="core/querying.html#triple-pattern-fragments"><strong>Triple Pattern Fragments</strong></a> allows querying for specific (combinations of) Subject, Property and Value.</li>
</ul>
<!-- - [**Bulk-API**](#bulk-api) allows fetching multiple subjects in one request -->
<ul>
<li><a href="core/querying.html#SPARQL"><strong>SRARQL</strong></a> is a powerful Query language for traversing graphs</li>
</ul>
<h2><a class="header" href="#subject-fetching-http" id="subject-fetching-http">Subject fetching (HTTP)</a></h2>
<p>The simplest way of getting Atomic Data when the Subject is an HTTP URL, is by sending a GET request to the subject URL.
Set the <code>Content-Type</code> header to an Atomic Data compatible mime type, such as <code>application/ad3-ndjson</code>.</p>
<pre><code class="language-HTTP">GET https://example.com/myResource HTTP/1.1
Content-Type: application/ad3-ndjson
</code></pre>
<p>The server SHOULD respond with all the Atoms of which the requested URL is the subject:</p>
<pre><code class="language-HTTP">HTTP/1.1 200 OK
Content-Type: application/ad3-ndjson
Connection: Closed

[&quot;https://example.com/myResource&quot;,&quot;https://example.com/properties/name&quot;,&quot;My awesome resource!&quot;]
</code></pre>
<p>The server MAY also include other resources, if they are deemed relevant.</p>
<h2><a class="header" href="#triple-pattern-fragments" id="triple-pattern-fragments">Triple Pattern Fragments</a></h2>
<p><a href="https://linkeddatafragments.org/specification/triple-pattern-fragments/">Triple Pattern Fragments</a> (TPF) is an interface for querying RDF.
It works great for Atomic Data as well.</p>
<p>An HTTP implementation of a TPF endpoint might accept a GET request to a URL such as this:</p>
<p><code>http://example.org/tpf?subject={subject}&amp;property={property}&amp;value={value}</code></p>
<p>Make sure to URL encode the <code>subject</code>, <code>property</code>, <code>value</code> strings.</p>
<p>For example, let's search for all Atoms where the value is <code>test</code>.</p>
<pre><code class="language-HTTP">GET https://example.com/tpf?value=&quot;test&quot; HTTP/1.1
Content-Type: application/ad3-ndjson
</code></pre>
<p>This is the HTTP response:</p>
<pre><code class="language-HTTP">HTTP/1.1 200 OK
Content-Type: application/ad3-ndjson
Connection: Closed

[&quot;https://example.com/myResource&quot;,&quot;https://example.com/properties/name&quot;,&quot;test&quot;]
</code></pre>
<!--
## Bulk API

Bulk-API is an (currently still closed) in-development specification for asking for multiple Subjects in one request.
This is especially useful in browser clients that traverse the graph iteratively, and HTTP/2 is not an option. -->
<h2><a class="header" href="#sparql" id="sparql">SPARQL</a></h2>
<p><a href="https://www.w3.org/TR/rdf-sparql-query/">SPARQL</a> is a powerful RDF query language.
Since all Atomic Data is also valid RDF, it is possible to query Atomic Data using SPARQL.</p>
<h1><a class="header" href="#atomic-schema" id="atomic-schema">Atomic Schema</a></h1>
<p>Atomic Schema is the proposed standard for specifying classes, properties and datatypes in Atomic Data.
You can compare it to what XSD is for XML.
Atomic Schema deals with the</p>
<p>This section will define various Classes, Properties and Datatypes (discussed in <a href="schema/../core/concepts.html">Atomic Core: Concepts</a>).</p>
<h2><a class="header" href="#design-goals-1" id="design-goals-1">Design Goals</a></h2>
<ul>
<li><strong>Typed</strong>: Every Atom of data has a clear datatype.</li>
<li><strong>IDE-friendly</strong>: You should not have to type full URLs - the schema sets shornames.</li>
<li><strong>Self-documenting</strong>: When seeing a piece of data, simply following links will explain you how the model is to be understood. This removes the need for (most of) existing API documentation.</li>
<li><strong>Performant</strong>: Datatypes can have a binary represenatation for optimal storage, communication, serialization and parsing efficiency.</li>
<li><strong>Extensible</strong>: Anybody can create their own Datatypes, Properties and Classes.</li>
<li><strong>Accessible</strong>: Support for languages, easily translateable. Useful for humans and machines.</li>
<li><strong>Atomic</strong>: All the design goals of Atomic Data itself also apply here.</li>
<li><strong>Self-describing</strong>: Atomic Schema is to be described as Atomic Data using Atomic Schema.</li>
</ul>
<h2><a class="header" href="#in-short" id="in-short">In short</a></h2>
<p>In short, Atomic Schema works like this:</p>
<p>The <strong>Property</strong> <em>field</em> in an Atom links to a Property <em>Resource</em>. It is important that the URL to the Property Resource resolves.
This Property does three things:</p>
<ol>
<li>it tells something about its semantic meaning, and links to a Datatype.</li>
<li>it links to a Datatype or Class, which indicates which Value is acceptable.</li>
<li>it provides a Shortname, which is used for ORM.</li>
</ol>
<p><strong>DataTypes</strong> define the shape of the Value, e.g. a Number (<code>124</code>) or Boolean (<code>true</code>).</p>
<p><strong>Classes</strong> are a special kind of Resource that describe an abstract class of things (such as &quot;Person&quot; or &quot;Blog&quot;).
Classes can <em>recommend</em> or <em>require</em> a set of Properties.
They behave as Models, similar to <code>struts</code> in C or <code>interfaces</code> in Typescript.
A Resource <em>could</em> have one or more classes, which <em>could</em> provide information about which Properties are expected or required.</p>
<h1><a class="header" href="#atomic-schema-classes" id="atomic-schema-classes">Atomic Schema: Classes</a></h1>
<h2><a class="header" href="#how-to-read-classes" id="how-to-read-classes">How to read classes</a></h2>
<p>Example:</p>
<ul>
<li><code>description</code> - (required, AtomicURL, LangString) human readable explanation of what the Class represents.</li>
</ul>
<p>Means:</p>
<p>This class has a <em>required</em> property with shortname <code>description</code>.
This Property has a Datatype of <code>AtomicURL</code>, and a classtype of <code>LangString</code>.</p>
<p><em>Note: the URLs for properties are missing and will be added at a later time.</em></p>
<h2><a class="header" href="#property-1" id="property-1">Property</a></h2>
<p><em>URL: <code>https://atomicdata.dev/classes/Property</code></em></p>
<p>The Property class.
The thing that the Property field should link to.
A Property is an abstract type of Resource that describes the relation between a Subject and a Value.
A Property provides some semantic information about the relationship (in its <code>description</code>), it provides a shorthand (the <code>shortname</code>) and it links to a Datatype.
Here's a <a href="schema/properties.html">list of useful Properties</a>.</p>
<p>Properties of a Property instance:</p>
<ul>
<li><code>shortname</code> - (required, Slug) the shortname for the property, used in ORM-style dot syntax (<code>thing.property.anotherproperty</code>).</li>
<li><code>description</code> - (optional, <a href="schema/datatypes.html#Langstring">Langstring</a>) the semantic meaning of the.</li>
<li><code>datatype</code> - (required, AtomicURL, Datatype) a URL to an Atomic Datatype, which defines what the datatype should be of the Value in an Atom where the Property is the</li>
<li><code>classtype</code> - (optional, AtomicURL, Class) if the <code>datatype</code> is an Atomic URL, the <code>classtype</code> defines which class(es?) is (are?) acceptable.</li>
</ul>
<pre><code class="language-ndjson">[&quot;https://example.com/properties/createdAt&quot;,&quot;https://atomicdata.dev/property/shortname&quot;,&quot;createdAt&quot;]
[&quot;https://example.com/properties/createdAt&quot;,&quot;https://atomicdata.dev/property/datatype&quot;,&quot;https://atomicdata.dev/datatype/datetime&quot;]
</code></pre>
<h2><a class="header" href="#datatype" id="datatype">Datatype</a></h2>
<p><em>URL: <code>https://atomicdata.dev/classes/Datatype</code></em></p>
<p>A Datatype specifies how a <code>Value</code> value should be interpreted.
Datatypes are concepts such as <code>boolean</code>, <code>string</code>, <code>integer</code>.
Since DatatTypes can be linked to, you dan define your own.
However, using non-standard datatypes limits how many applications will know what to do with the data.</p>
<p>Properties:</p>
<ul>
<li><code>description</code> - (required, langstring) how the datatype functions.</li>
<li><code>stringSerialization</code> - (required, AtomicURL, LangString) how the datatype should be parsed / serialized as an UTF-8 string</li>
<li><code>stringExample</code> - (required, string) an example stringSerialization example value that should be parsed correclty</li>
<li><code>binarySerialization</code> - (optional, AtomicURL, LangString) how the datatype should be parsed / serialized as a byte array.</li>
<li><code>binaryExample</code> - (optional, string) an example stringSerialization that should be parsed correclty. Should have the same contents as the stringExample. Required if binarySerialization is present on the DataType.</li>
</ul>
<h2><a class="header" href="#class" id="class">Class</a></h2>
<p><em>URL: <code>https://atomicdata.dev/classes/Class</code></em></p>
<p>A Class is an abstract type of Resource, such as <code>Person</code>.
It is convention to use an Uppercase in its URI.
Note that in Atomic Data, a Resource can have several Classes - not just a single one.</p>
<p>Properties:</p>
<ul>
<li><code>shortname</code> - (required, Slug) a short string shorthand.</li>
<li><code>description</code> - (required, AtomicURL, LangString) human readable explanation of what the Class represents.</li>
<li><code>requires</code> - (optional, ResourceArray) a list of Properties that are required. If absent, none are required. These SHOULD have unique shortnames.</li>
<li><code>recommends</code> - (optional, ResourceArray) a list of Properties that are recommended. These SHOULD have unique shortnames.</li>
</ul>
<!-- Maybe remove this next one? -->
<!-- - `disallowedProperties` - (optional, ResourceArray) a list of Properties that are not allowed.  If absent, all are allowed. -->
<!-- What are the consequences of this? How to deal with this field if there are more classes in aSSubject? -->
<!-- - `allowedProperties` - (optional, ResourceArray) a list of Properties that are allowed. If absent, none are required. -->
<p>Example:</p>
<pre><code class="language-ndjson">[&quot;https://example.com/classes/Person&quot;,&quot;https://atomicdata.dev/properties/isA&quot;,&quot;Class&quot;]
[&quot;https://example.com/classes/Person&quot;,&quot;https://atomicdata.dev/properties/datatype&quot;,&quot;https://atomicdata.dev/datatypes/datetime&quot;]
</code></pre>
<p>Incoming Properties:</p>
<ul>
<li><code>class</code> - The Class of the Resource</li>
</ul>
<h2><a class="header" href="#langstring" id="langstring">LangString</a></h2>
<p><em>URL: <code>https://atomicdata.dev/classes/Class</code></em></p>
<p>A language specific string. (<a href="https://github.com/ontola/atomic-data/issues/6">discussion</a>)</p>
<ul>
<li><code>lang</code> - (required, string) a <a href="http://www.rfc-editor.org/rfc/bcp/bcp47.txt">BCP 47</a> language tag, e.g. <code>en-US</code>.</li>
<li><code>text</code> - (required, string) the contents of the string.</li>
</ul>
<h1><a class="header" href="#atomic-schema-datatypes" id="atomic-schema-datatypes">Atomic Schema: Datatypes</a></h1>
<p>The Atomic Datatypes consist of some of the most commonly used <a href="schema/classes.html#Datatype">Datatypes</a>.</p>
<p>A Datatype is</p>
<h2><a class="header" href="#slug" id="slug">Slug</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/slug</code></em></p>
<p>A string with a limited set of allowed characters, used in IDE / Text editor context.</p>
<h2><a class="header" href="#atomic-uri" id="atomic-uri">Atomic URI</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/atomicURI</code></em></p>
<p>A URL that should resolve to an <a href="schema/../core/concepts.html#Resource">Atomic Resource</a>.</p>
<h2><a class="header" href="#uri" id="uri">URI</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/URI</code></em></p>
<p>A Uniform Resource Identifier, preferably a URL (i.e. an URI that can be fetched).
Could be HTTP, HTTPS, or any other type of schema.</p>
<h2><a class="header" href="#string" id="string">String</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/string</code></em></p>
<p>UTF-8 String, no max character count.
Newlines use backslash escaped <code>\n</code> characters.
Should not contain language specific data, use a <code>langstring</code> instead (which is a linked resource).</p>
<p>e.g. <code>String time! \n Second line!</code></p>
<h2><a class="header" href="#integer" id="integer">Integer</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/integer</code></em></p>
<p>Signed Integer, max 64 bit.
Max value: <a href="https://en.wikipedia.org/wiki/9,223,372,036,854,775,807"><code>9223372036854775807</code></a></p>
<p>e.g. <code>-420</code></p>
<h2><a class="header" href="#boolean" id="boolean">Boolean</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/boolean</code></em></p>
<p>True or false, one or zero.</p>
<p><strong>String serialization</strong></p>
<p><code>true</code> or <code>false</code>.</p>
<p><strong>Binary serialization</strong></p>
<p>Use a single bit one boolean.</p>
<p>1 for <code>true</code>, or 0 for <code>false</code>.</p>
<h2><a class="header" href="#datetime" id="datetime">Datetime</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/dateTime</code></em></p>
<p>ISO 8601 encoded string.</p>
<p>e.g. <code>2020-06-11</code></p>
<h2><a class="header" href="#mimefile" id="mimefile">MIMEFile</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/mimeFile</code></em></p>
<p>Any type of file, starting with its <a href="https://www.iana.org/assignments/media-types/media-types.xhtml">mime type</a>
Although MIME types <a href="https://stackoverflow.com/a/29019569/2502163">often don't exist in your OS</a>, specifying them seems like a good idea.</p>
<p><strong>String serialization</strong></p>
<p>Start with the mimetype string, do a newline <code>\n</code> and continue with the UTF-8 stringified data.</p>
<ul>
<li>e.g. <code>application/text\nOh hi mark</code></li>
<li>e.g. <code>text/html\n&lt;html&gt;&lt;p&gt;oh, hi mark&lt;/p&gt;&lt;/html&gt;</code></li>
</ul>
<h2><a class="header" href="#resourcearray" id="resourcearray">ResourceArray</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/resourceArray</code></em></p>
<p>Sequential, ordered list of Atomic URIs.
Serialized as a JSON array with strings.
Note that other types of arrays are not included in this spec, but can be perfectly valid.</p>
<ul>
<li>e.g. <code>[&quot;https://example.com/1&quot;, &quot;https://example.com/1&quot;]</code></li>
</ul>
<h2><a class="header" href="#" id=""></a></h2>
<h1><a class="header" href="#atomic-schema-faq" id="atomic-schema-faq">Atomic Schema FAQ</a></h1>
<h2><a class="header" href="#how-do-i-create-a-property-that-supports-multiple-datatypes" id="how-do-i-create-a-property-that-supports-multiple-datatypes">How do I create a Property that supports multiple Datatypes?</a></h2>
<p>A property only has one single Datatype.
However, feel free to create a new kind of Datatype that, in turn, refers to other Datatypes.
Perhaps Generics, or Option like types should be part of the Atomic Base Datatypes.</p>
<h2><a class="header" href="#how-should-a-client-deal-with-shortname-collisions" id="how-should-a-client-deal-with-shortname-collisions">How should a client deal with Shortname collisions?</a></h2>
<p>Atomic Data guarantees Subject-Property uniqueness, which means that Valid Resources are guanranteed to have only one of each Property.
Properties offer Shortnames, which are short strings.
These strings SHOULD be unique inside Classes, but these are not guaranteed to be unique inside all Resources.
Note that Resources can have multiple Classes, and throught that, they can have colliding Shortnames.
Resources are also free to inlcude Properties from other Classes, and their Shortnames, too, might collide.</p>
<p>For example:</p>
<pre><code class="language-ndjson">[&quot;https://example.com/people/123&quot;, &quot;https://example.com/name&quot;, &quot;John&quot;]
[&quot;https://example.com/people/123&quot;, &quot;https://somepage.example.com/name&quot;, &quot;John&quot;]
</code></pre>
<p>Let's assume that <code>https://somepage.example.com/name</code> and <code>https://example.com/name</code> are Properties that have the Shortname: <code>name</code>.</p>
<p>What if a client tries something such as <code>people123.name</code>?
To consistently return a single value, we need some form or precendence, and it goes like this:</p>
<ol>
<li>The earlier Class mentioned in the <code>class</code> Property of the resource. Resources can have multiple classes, but they appear in an ordered ResourceArray. Classes, internally SHOULD have no key collissions in required and recommended properties, which means that they might have. If these exist internally, sort the properties from A-Z.</li>
</ol>
<!-- This  -->
<ol>
<li>When the Properties are not part of any of the mentioned Classes, use Alphabetical sorting of the Property URL.</li>
</ol>
<p>When shortname colisions are possible, it's recomended to not use the shortname, but use the URL of the Property:</p>
<pre><code>people123.&quot;https://example.com/name&quot;
</code></pre>
<h2><a class="header" href="#atomic-data-uses-a-lot-of-links-how-do-you-deal-with-links-that-dont-work" id="atomic-data-uses-a-lot-of-links-how-do-you-deal-with-links-that-dont-work">Atomic Data uses a lot of links. How do you deal with links that don't work?</a></h2>
<p>Fir</p>
<ol>
<li>Use URIs schemes that use content adressing, such as IPFS URIs.</li>
<li>Use URIs schemes that use content adressing, such as IPFS URIs.</li>
</ol>
<h2><a class="header" href="#whats-a-uri-and-whats-a-url" id="whats-a-uri-and-whats-a-url">What's a URI, and what's a URL?</a></h2>
<p>URI stands for Unique Resource Identifier</p>
<h1><a class="header" href="#atomic-mutations" id="atomic-mutations">Atomic Mutations</a></h1>
<p>Atomic Mutations is a proposed standard for communicating state changes of <a href="mutations/../core/intro.html">Atomic Data</a>.
It is the part of Atomic Data that is concerned with writing, editing and updating.</p>
<p><em>Disclaimer: This part of the draft spec lacks even more clarity than the others, and is constantly moving.</em></p>
<h2><a class="header" href="#design-goals-2" id="design-goals-2">Design goals</a></h2>
<ul>
<li><strong>Event sourced</strong>: Store State changes, as well as the current state. This enables versioning, history playback, undo, audit controls, and more.</li>
<li><strong>Traceable origin</strong>: Every state change should be traceable to an actor and a point in time.</li>
<li><strong>Verifiable</strong>: Have cryptographic proof for every state change.</li>
<li><strong>Decentralized</strong>: Can be used in P2P networks to send mutations from device to device.</li>
<li><strong>Extensible</strong>: The methods are not fixed, and can be added by anyone.</li>
<li><strong>Streamable</strong>: The state changes could be used in streaming context, e.g. a client app that reads data that changes every second.</li>
<li><strong>Atomic</strong>: All the Atomic Data design goals also apply here.</li>
</ul>
<h2><a class="header" href="#motivation-1" id="motivation-1">Motivation</a></h2>
<p>So many problems that confine data exchange are the result of thinking in current-state exchange.
State synchronization is often an afterthought, and ... TODO!</p>
<p>Keeping track of where data comes from is essential to knowing whether you can trust it - whether you consider it to be true.
When you want to persist data, that quickly becomes bothersome.
Atomic Data and Atomic Mutations aim to make this easier by using cryptography for ensuring data comes from some particular source, and is therefore trustworthy.</p>
<h2><a class="header" href="#in-short-1" id="in-short-1">In short</a></h2>
<ul>
<li><a href="mutations/concepts.html">Atomic Mutations</a> are small pieces of information that descibe how a Resource was changed. Think of these as Commits which are</li>
<li><a href="mutations/concepts.html">Atomic Suggestions</a> are small pieces of information that suggest how a Resource should be changed.</li>
</ul>
<h1><a class="header" href="#atomic-mutations-concepts" id="atomic-mutations-concepts">Atomic Mutations: Concepts</a></h1>
<h2><a class="header" href="#mutation" id="mutation">Mutation</a></h2>
<p>The smallest possible piece of a state change.
A mutation describes how an Resource should be updated.
An Atomic Mutation consists of a:</p>
<ul>
<li><code>subject</code> - the Thing that the atom is providing information about. (must be a URI to an Atomic Thing)</li>
<li><code>property</code> - the property of the Thing that the atom is about. (must be a URI to an Atomic Property)</li>
<li><code>value</code> - the new piece of information about the Atom (can be any datatype, as long as its defined by the property)</li>
<li><code>method</code> - How the resource needs to be updated using the Atom. If empty, just replace the current state.</li>
<li><code>hash</code> - The <a href="mutations/versioning.html#Hashing">IPFS URL</a> of the updated version of the resource. If this does not match with your resource, the Mutation is faulty. The hash can be empty if it is sent in</li>
<li><code>date</code> - A timestamp of when the mutation was created.</li>
</ul>
<!-- Should it have an actor?  -->
<ul>
<li><code>actor</code> - A timestamp of when the mutation was created.</li>
</ul>
<h2><a class="header" href="#ledger" id="ledger">Ledger</a></h2>
<p>A Ledger is an (append-only) log of Mutations.</p>
<p>TODO!</p>
<h2><a class="header" href="#commit" id="commit">Commit</a></h2>
<p>A Commit is a set of Mutations, made by some Actor</p>
<p>TODO!</p>
<h2><a class="header" href="#serialization-with-atomicmutations-ndjson" id="serialization-with-atomicmutations-ndjson">Serialization with AtomicMutations-ndjson</a></h2>
<p>Altough Mutations can be communicated with</p>
<p>Work in progress, see <a href="https://github.com/ontola/linked-delta">linked-delta</a>.</p>
<pre><code class="language-ndjson">[&quot;https://example.com/john&quot;, &quot;https://example.com/properties/lastName&quot;, &quot;Mc'Lovin&quot;, &quot;https://purl.org/linked-delta/add&quot;, &quot;AEF1245612F3&quot;]
</code></pre>
<h2><a class="header" href="#streaming-pubsub" id="streaming-pubsub">Streaming (pub/sub)</a></h2>
<p>We're using HexTuples-NDJSON, since that allows for streaming parsing of mutations.</p>
<p>TODO! Something about endpoints / protocol for pub/sub.</p>
<h2><a class="header" href="#base-methods" id="base-methods">Base Methods</a></h2>
<p>See <a href="http://purl.org/linked-delta">linked-delta</a></p>
<h1><a class="header" href="#atomic-suggestions" id="atomic-suggestions">Atomic Suggestions</a></h1>
<p>Atomic Suggestions is a proposed standard that enables decentralized collaboration on resources.
It's basically Git for linked data.</p>
<!-- It describes how proposals for data changes -->
<h2><a class="header" href="#design-goals-3" id="design-goals-3">Design goals</a></h2>
<ul>
<li><strong>Asynchronous collaboration</strong>: Various users can work on the same thing at the same time.</li>
<li><strong>Branching &amp; merging</strong>: Issues that result from async changes (merge conflicts) can be resolved.</li>
</ul>
<h2><a class="header" href="#concepts" id="concepts">Concepts</a></h2>
<h3><a class="header" href="#suggestion" id="suggestion">Suggestion</a></h3>
<!-- Perhaps suggestions are too similar to Mutations, and should be merged into a single concept? -->
<p>A Suggestion is a (set of?) Mutation(s?) that is proposed to be appended to some Ledger.
The important difference between a Suggestion and a Mutation, is that a Mutation has been verified, signed and approved by the Controller.</p>
<h3><a class="header" href="#controller" id="controller">Controller</a></h3>
<p>The actor (person / organization) that is in control of a specific Resource and its mutations.</p>
<h3><a class="header" href="#inbox" id="inbox">Inbox</a></h3>
<p>An Inbox represents an endpoint that accepts incoming Suggestions.
It's similar to an e-mail inbox.</p>
<h1><a class="header" href="#atomic-data-versioning" id="atomic-data-versioning">Atomic Data Versioning</a></h1>
<p>When Atomic Mutations are applied to some Resource, the resource will change.
However, its identifier (the Subject) will often remain the same.</p>
<ul>
<li>Versioned representations should provide a link to the authority that might update it, and a link to where the latest version can be found.</li>
<li>The latest version should have a link to its permanent verison.</li>
<li>Should <a href="mutations/../interoperability/ipfs.html">IPFS</a> content-hash URLs be used for Versioned resources?</li>
</ul>
<h2><a class="header" href="#versioned-resources" id="versioned-resources">Versioned Resources</a></h2>
<p>Properties:</p>
<!-- Maybe this is not required, if we assume that the subject URL should always show the latest? -->
<ul>
<li>latest: (ResourceArray, optional)</li>
<li>versions: (ResourceArray, optional)</li>
<li>currentVersion: (ResourceURL, required)</li>
</ul>
<h2><a class="header" href="#static-resource" id="static-resource">Static Resource</a></h2>
<p>A static resource has a <em>content adressible</em> URL, which means that its URL will never change.</p>
<h2><a class="header" href="#hashing" id="hashing">Hashing</a></h2>
<ul>
<li>Serialize all Atoms of the Subject (the entire Resource) as Atomic-NDJSON</li>
<li>Sort all lines (every atom) alphabetically</li>
</ul>
<h1><a class="header" href="#interoperability-relation-to-other-technology" id="interoperability-relation-to-other-technology">Interoperability: Relation to other technology</a></h1>
<p>Atomic data is designed to be highly interoperable.</p>
<h2><a class="header" href="#data-formats" id="data-formats">Data formats</a></h2>
<p>It is possible to convert Atomic to many types of serialization formats.</p>
<ul>
<li><a href="interoperability/rdf.html">RDF</a>: some RDF can be automatically converted into valid Atomic data.</li>
<li><a href="interoperability/json.html">JSON</a>: JSON requires a mapping to Atomic Properties, and explicit</li>
</ul>
<h2><a class="header" href="#protocols" id="protocols">Protocols</a></h2>
<ul>
<li><a href="interoperability/ipfs.html">IPFS</a>: Content-based adressing to prevent 404s and centralization</li>
</ul>
<h1><a class="header" href="#atomic-data-and-ipfs" id="atomic-data-and-ipfs">Atomic Data and IPFS</a></h1>
<h2><a class="header" href="#what-is-ipfs" id="what-is-ipfs">What is IPFS</a></h2>
<p>IPFS (the InterPlanetery File System) is a standard that enables decentralized file storage and retrieval using content-based identifiers.
Intead of using an HTTP URL like <code>http://example.com/helloworld</code>, it uses the IPFS scheme, such as <code>ipfs:QmX6j9DHcPhgBcBtZsuRkfmk2v7G5mzb11vU9ve9i8vDsL</code>.
IPFS identifies things based on their unique content hash (the long, seemingly random string) using a thing called a Merkle DAG (<a href="https://medium.com/textileio/whats-really-happening-when-you-add-a-file-to-ipfs-ae3b8b5e4b0f#:%7E:text=In%20practice%2C%20content%20addressing%20systems,function%2C%20to%20produce%20a%20digest.&amp;text=From%20raw%20image%20to%20cryptographic%20digest%20to%20content%20id%20(multihash).">this great article</a> explains it nicely).
This simple idea (plus some not so simple network protocols) allows for decentalized, temper-proof storage of data.
This fixes some issues with HTTP that are related to its centralized philosophy: no more 404s!</p>
<h2><a class="header" href="#why-is-ipfs-especially-interesting-for-atomic-data" id="why-is-ipfs-especially-interesting-for-atomic-data">Why is IPFS especially interesting for Atomic Data</a></h2>
<p>Atomic Data is highly dependent on the availability of Resources, especially Properties and Datatypes.
These resources are meant to be re-used a lot, and that would make everything expensive.</p>
<h2><a class="header" href="#considerations-using-ipfs-urls" id="considerations-using-ipfs-urls">Considerations using IPFS URLs</a></h2>
<p>They are static, their contents can never change.
This is great for some types of data, but horrible for others.
If you're describing a time-dependent thing (such as a person's job),
If you're describing personal, private information, its also a bad idea to use IPFS, because it's designed to be permanent.
Also, IPFS is not as fast as HTTP - at least for now.</p>
<h2><a class="header" href="#example-of-atomic-data-on-ipfs" id="example-of-atomic-data-on-ipfs">Example of Atomic Data on IPFS</a></h2>
<p>Here's an example, serialized to Atomic-NDJSON:</p>
<p><a href="https://ipfs.io/ipfs/QmX6j9DHcPhgBcBtZsuRkfmk2v7G5mzb11vU9ve9i8vDsL">https://ipfs.io/ipfs/QmX6j9DHcPhgBcBtZsuRkfmk2v7G5mzb11vU9ve9i8vDsL</a></p>
<pre><code class="language-ndjson">[&quot;https://atomicdata.dev/helloworld&quot;,&quot;https://atomicdata.dev/properties/description&quot;,&quot;Hello world!&quot;]
</code></pre>
<h2><a class="header" href="#atomic-data-and-ipld" id="atomic-data-and-ipld">Atomic Data and IPLD</a></h2>
<p>IPLD (not IPFS) stands for InterPlanetery Linked Data, but is not related to RDF.
The scope seems fundamentally different from RDF, too, but I have to read more about this.
TODO!</p>
<h1><a class="header" href="#how-does-atomic-data-relate-to-rdf" id="how-does-atomic-data-relate-to-rdf">How does Atomic Data relate to RDF?</a></h1>
<p>RDF is the original data model behind linked data.
It is also the forerunner of Atomic Data, and is therefore highly similar in its philosophy and model.
Both heavily rely on using URLs, and both have a fundamentally simple and uniform model for data statements.
Both view the web as a single, connected graph database.
Because of that, Atomic Data is also highly compatible with RDF - <strong>all Atomic Data can be converted into valid RDF</strong>.
Atomic Data can be thought of as a <strong>more constrained, type safe version of RDF</strong>.
However, it does differ in some fundamental ways.</p>
<ul>
<li>
<p>Atomic calls the three parts of a Triple <code>subject</code>, <code>property</code> and <code>value</code>, instead of <code>subject</code>, <code>predicate</code>, <code>object</code>.</p>
</li>
<li>
<p>Atomic requires URL (not URI) values in its <code>subjects</code> and <code>predicates</code> (properties), which means that they should be resolveable.</p>
</li>
<li>
<p>Atomic only allows those who control a resource's <code>subject</code> URL endpoint to edit the data. This means that you can't add triples about something that you don't control.</p>
</li>
<li>
<p>Atomic has no seperate <code>datatype</code> field, but it requires that <code>Properties</code> (the resources that are shown when you folllow a <code>predicate</code> value) specify a datatype</p>
</li>
<li>
<p>Atomic has no seperate <code>language</code> field, but it does support language strings as a Datatype in Properties.</p>
</li>
<li>
<p>Atomic has a native Event (state changes) model (<a href="interoperability/../mutations/intro.html">Atomic Mutations</a>), which enables communication of state changes</p>
</li>
<li>
<p>Atomic has a native Schema model (<a href="interoperability/../schema/intro.html">Atomic Schema</a>), which helps developers to know what data types they can expect (string, integer, link, array)</p>
</li>
<li>
<p>Atomic does not support <code>graph</code> fields in statments.</p>
</li>
<li>
<p>Atomic does not support <code>blank nodes</code>.</p>
</li>
<li>
<p>Atomic does not support having multiple statements with the same <code>&lt;subject&gt; &lt;predicate&gt;</code>, every combination should be unique.</p>
</li>
</ul>
<h2><a class="header" href="#why-these-changes" id="why-these-changes">Why these changes?</a></h2>
<p>I love RDF, and have been working with it for quite some time now.
Using URIs (and moreso URLs, which are URIs that can be fetched) for everything is a great idea, since it helps with interoperability and enables truly decentralized knowledge graphs.
However, some of the characteristics of RDF might have contributed to its relative lack of adoption.</p>
<ul>
<li>RDF's <code>subject</code>, <code>predicate</code> and <code>object</code> terminology can be confusing to newcomers, so Atomic Data uses <code>subject</code>, <code>property</code>, <code>value</code>. This more closely resembles known CS terminology. (<a href="https://github.com/ontola/atomic-data/issues/3">discussion</a>)</li>
<li>Having both a <code>datatype</code> and a <code>predicate</code> value can lead to confusing situations. For example, the <a href="https://schema.org/dateCreated"><code>schema:dateCreated</code></a> Property requires an ISO DateTime string (according to the schema.org definition), but using a value <code>true</code> with an <code>xsd:boolean</code> datatype results in perfectly valid RDF. This means that client software using triples with a <code>schema:dateCreated</code> predicate cannot safely assume that its value will be a DateTime. So if the client wants to use <code>schema:dateCreated</code> values, the client must also specify which type of data it expects, check the datetype field of every Atom and provide logic for when these don't match. Also important: developers tend to combine these two concepts into one - just look at how every single struct / model / class / shape is defined in programming languages: <code>key: datatype</code>. This is why Atomic Data requires that a <code>predicate</code> links to a Property which must have a <code>Datatype</code>.</li>
<li>Using full URI strings as keys (in RDF <code>predicates</code>) results in a relatively clunky Developer Experience. Consider the short strings that developers are used to in pretty much all languages and data formats (<code>object.attribute</code>). Adding a <em>required</em> / tightly integrated key mapping (from long URLs to short, simple strings) in Atomic Properties solves this issue, and provides developers a way to write code like this: <code>someAtomicPerson.bestFriend.name =&gt; &quot;Britta&quot;</code>. Although the RDF ecosystem does have some solutions for this (@context objects in JSON-LD, @prefix mappings, the @ontologies library), these prefixes are not defined in Properties themselves and therefore are defined locally only, which means that developers have to manually map them most of the time. This is why Atomic Data introduces a <code>shortname</code> field in Properties, which forces modellers to choose a 'key' that can be used in ORM contexts.</li>
<li>RDF lacks a clear solution for dealing with <a href="https://ontola.io/blog/ordered-data-in-rdf/">ordered data</a>, resulting in confusion when developers have to create lists of content. Adding an Array data type as a base data type helps solve this. (<a href="https://github.com/ontola/atomic-data/issues/4">discussion</a>)</li>
<li>There is no integrated standard for communicating state changes. Although <a href="https://github.com/ontola/linked-delta">linked-delta</a> and <a href="https://afs.github.io/rdf-delta/">rdf-delta</a> do exist, they aren't refered to by the RDF spec. I think developers need guidance when learning a new system such as RDF, and that's why <a href="interoperability/../mutations/intro.html">Atomic Mutations</a> is included in this book.</li>
<li>RDF allows that <code>anne</code> creates statements about the subject <code>john</code>. The reasoning behind this, was that it was possible to say things about thingsIn other words, domain A creates statements about domain B. This means that someone using RDF data about domain B cannot know that domain B is actually the source of the data. Knowing <em>where data comes from</em> is one of the great things about URIs, but RDF does not require that you can think of subjects as the source of data. Many subjects in RDF don't actually resolve to all the known triples of the statement. It would make the conceptual model way simpler if statements about a subject could only be made from the source of the domain owner of the subject.</li>
<li>RDF allows blank nodes, Atomic Data does not. They make things easier for content providers, but make things <a href="http://richard.cyganiak.de/blog/2011/03/blank-nodes-considered-harmful/">harder for content consumers</a>. They severely limit how client systems can store the data, as name collisions with blank nodes are very possible. They make sense in hand-written Turtle files, but that argument doesn't hold for systems that create the data (and the identifiers) for you. It's very much possible to design systems that create reliable URLs without any overhead for the data creator.</li>
<li>RDF allows any type of URIs for <code>subject</code> and <code>predicate</code> value, which means they can be URLs, but don't have to be. This means they don't always resolve, or even function as locators. The links don't work, and that restricts how useful the links are. Atomic Data takes a different approach: these links MUST Resolve. Requiring that is part of what enables the type system of Atomic Schema</li>
</ul>
<p>Besides these technical reasons about the RDF model, I think that there are more reasons to start with a new concept and give it a new name:</p>
<ul>
<li>The RDF documentation is intimidating for beginners. When trying to understand RDF, you're likely to traverse. All Core / Schema URLs should resolve to simple, clear explanations with both examples and machine readable definitions.</li>
<li>There is a lack of learning resources that provide a clear, complete answer to the lifecycle of RDF data: modelling data, making data, hosting it, fetching it, updating it. Atomic Data aims to provide an opinionated answer to all of these steps.</li>
<li>The Semantic Web community has had a lot of academic attention from formal logic departments, resulting in a highly developed standard for knowledge modelling: the Web Ontology Language (OWL). While this is mostly great, its open-world philosophy and focus on reasoning abilities can confuse developers who are simply looking for a simple way to share models in RDF.</li>
</ul>
<!-- - Re-using predicate URIs in new contexts can be result in unclear descriptions, since the meaning of predicates can be very class-dependent. For examle, a `name` for a Person means something else than a `name` for a  -->
<h2><a class="header" href="#convert-atomic-data-to-rdf" id="convert-atomic-data-to-rdf">Convert Atomic data to RDF</a></h2>
<p>Since all Atomic Data is also valid RDF, it's trivial to convert / serialize Atoms to RDF.</p>
<ul>
<li>Convert Atoms with linked <code>LangString</code> Values to Literals with an <code>xsd:string</code> datatype and the corresponding language in the tag.</li>
</ul>
<h2><a class="header" href="#convert-rdf-to-atomic-data" id="convert-rdf-to-atomic-data">Convert RDF to Atomic Data</a></h2>
<ul>
<li>All <code>predicates</code> SHOULD resolve to Atomic Properties, and these SHOULD have a <code>datatype</code>. This means that the <code>datatype</code> in the original RDF statement can be dropped.</li>
<li>Literals with a <code>language</code> tag are converted to the <code>atomic:langstring</code> type. TODO! How to fis</li>
</ul>
<h1><a class="header" href="#how-does-atomic-data-relate-to-json" id="how-does-atomic-data-relate-to-json">How does Atomic Data relate to JSON?</a></h1>
<p>Atomic Data is a stricter subset of RDF, and the most popular serialization of RDF for JSON data is <a href="https://json-ld.org/">JSON-LD</a>.
When converting JSON to Atomic Data and the other way around, its best to use this format.</p>
<h2><a class="header" href="#from-json-to-atomic-data" id="from-json-to-atomic-data">From JSON to Atomic Data</a></h2>
<p>Atomic Data requires a bit more information about pieces of data than JSON tends to contain. Let's take a look at a regular JSON example:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;John&quot;,
  &quot;birthDate&quot;: &quot;1991-01-20&quot;
}
</code></pre>
<p>We need more information to convert this JSON into Atomic Data.
The following things are missing:</p>
<ul>
<li>What is the Subject URL of the resource being described?</li>
<li>What is the Prediate URL of the keys being used? (<code>name</code> and <code>birthDate</code>), and consequentially, how should the values be parsed? What are their DataTypes?</li>
</ul>
<p>We can add this data by adding some <em>@context</em>:</p>
<pre><code class="language-json">{
  &quot;@context&quot;: {
    &quot;name&quot;: &quot;https://example.com/properties/name&quot;,
    &quot;birthDate&quot;: &quot;https://example.com/properties/birthDate&quot;,
    &quot;@id&quot;: &quot;https://example.com/people/john&quot;
  },
  &quot;name&quot;: &quot;John&quot;,
  &quot;birthDate&quot;: &quot;1991-01-20&quot;
}
</code></pre>
<p>The JSON above is called JSON-LD.
It is still perfectly valid JSON, but it contains more information, and in turn can be converted into RDF formats.</p>
<h2><a class="header" href="#from-atomic-data-to-json" id="from-atomic-data-to-json">From Atomic Data to JSON</a></h2>
<p>Since Atomic Schema requires the presence of a <code>key</code> slug in Properties, converting Atomic Data to JSON results in dev-friendly objects with nice shorthands.</p>
<pre><code class="language-ndjson">[&quot;https://example.com/john&quot;,&quot;https://example.com/properties/lastname&quot;,&quot;Houdini&quot;]
[&quot;https://example.com/john&quot;,&quot;https://example.com/properties/bestFriend&quot;,&quot;https://example.com/sarah&quot;]
</code></pre>
<p>Can be automatically converted to:</p>
<pre><code class="language-json">{
  &quot;@context&quot;: {
    &quot;name&quot;: &quot;https://example.com/properties/lastname&quot;,
    &quot;bestFriend&quot;: &quot;https://example.com/properties/bestFriend&quot;,
  },
  &quot;name&quot;: &quot;John&quot;,
  &quot;bestFriend&quot;: {
    &quot;@id&quot;: &quot;https://example.com/sarah&quot;
  },
}
</code></pre>
<p>The <code>@context</code> object provides a <em>mapping</em> to the original URLs.
The <code>@id</code> key shows that the value should be interpreted as a link (a URI).</p>
<h2><a class="header" href="#json-ld-requirements" id="json-ld-requirements">JSON-LD Requirements</a></h2>
<ul>
<li>Make sure the URLs used in the <code>@context</code> resolve to Atomic Properties.</li>
</ul>
<!-- Not sure about this.. maybe use RDF collections or some other model? -->
<ul>
<li>Convert JSON-LD arrays into ResourceArrays</li>
<li>Creating nested JSON objects is possible (by resolving the identifiers from <code>@id</code> relations), but it is up to the serializer to decide how deep this object nesting should happen.</li>
</ul>
<h2><a class="header" href="#considerations" id="considerations">Considerations</a></h2>
<ul>
<li>Whilst JSON-LD is great for traditional JSON usage (dot.syntax ORM style navigation of objects), it is not great for linked data usage.</li>
</ul>
<h1><a class="header" href="#types-of-atomic-graphs" id="types-of-atomic-graphs">Types of Atomic Graphs</a></h1>
<p>An Graph is a set of Atoms.
Since Atomic Data is desgigned to facilitate decentralized data storage, Graphs will often lack information or contain invalid data.
In this section, we define some of these aspects of Graphs.</p>
<ul>
<li>A <strong>Valid Graph</strong> contains no mismatches between Datatypes from Properties and their usage in Atoms</li>
<li>A <strong>Closed Graph</strong> contains no unfetched outgoing links</li>
<li>A <strong>Verified Graph</strong> contains only Atoms from a verified Author</li>
<li>A <strong>Schema Complete Graph</strong> contains all used linked Properties</li>
</ul>
<p>These concepts are important when creating an implementation of a Store.</p>
<h2><a class="header" href="#valid-graphs" id="valid-graphs">Valid Graphs</a></h2>
<p>We refer to a Graph as Valid, if the following constraints are met:</p>
<ul>
<li><strong>The Datatypes are correctly used</strong>. The Graph does not contain Atoms where the Datatype of the Value does not match the Datatype of the Property of the Atom.</li>
<li><strong>The links work</strong>. All URLs used in the Graph (Subject, Property, Value) resolve correctly to the required Datatype.</li>
<li><strong>The Class Restrictions are met</strong>. If a Class sets required properties, these must be present in Resources that are instances of that Class.</li>
</ul>
<p>Making sure Graphs are Valid is of great imporance to anyone creating, sharing or using Atomic Data.
Services should specify whether they check the validity of graphs.</p>
<h2><a class="header" href="#closed-graph" id="closed-graph">Closed Graph</a></h2>
<p>A Graph is Closed, when the Resources of all URLs are present in the Graph.
In other words, if you were to fetch and download every single URL in a Graph, you would not have any more Atoms than before.
There are no more unfetched outgoing links.</p>
<p>Closed Graphs are <em>rarely</em> required in Atomic Data; it's often perfectly fine to have outgoing links that do not have been fetched.</p>
<h2><a class="header" href="#verified-graph" id="verified-graph">Verified Graph</a></h2>
<p>When you are given some Atomic Graph by someone, you initially don't know for sure whether the Atoms themselves are actually created by the one controlling the subject URL.
Someone may have tempered with the data, or fabricated it.</p>
<p>The process of Verification can be done in two ways:</p>
<ol>
<li><strong>Request the subjects, and check if the atoms match</strong>.</li>
<li><strong>Verify the signatures of the Resources or Mutations</strong></li>
</ol>
<p>When one of these steps is taken, we say that the Graph is Verified.</p>
<h2><a class="header" href="#schema-complete-graphs" id="schema-complete-graphs">Schema Complete Graphs</a></h2>
<p>When a Graph has a set of Atoms, it might not posess all the information that is required to determine the datatype of each Atom.
When that is the case, we say the Graph is <em>Schema Complete</em>.</p>
<p>Having a Schema Complete Graph is essential for determining what the Datatype is of a Value.
Most implementations of Atomic Data will need Schema Completenss to create fitting views, or apply functinoal business logic.</p>
<p>Imagine some application (perhaps an app running inside a webbrowser) that has only the following data:</p>
<pre><code class="language-ndjson">[&quot;https://example.com/john&quot;,&quot;https://example.com/birthDate&quot;,&quot;1991-01-20&quot;]
</code></pre>
<p>Now, by looking at this single Atom, we might assume that the Value is an ISO date,
but this type information is not known yet to the application.
This type information should be specified in the <code>example:birthDate</code> Property.
It is the responsibility of the application to make sure it posesses the required Schema data.</p>
<p>We say a Graph is <em>Schema Complete</em> when it contains <em>at least</em> all the Propertie Classes that are used in the Property fields.</p>
<p>So let's add the missing Property: <code>https://example.com/birthDate</code></p>
<pre><code class="language-ndjson">[&quot;https://example.com/john&quot;,&quot;https://example.com/birthDate&quot;,&quot;1991-01-20&quot;]
[&quot;https://example.com/birthDate&quot;,&quot;https://atomicdata.dev/datatypes/Datatype&quot;,&quot;https://atomicdata.dev/datatypes/dateTime&quot;]
</code></pre>
<p>Now, since we've introduced yet another Property, we need to include that one as well:</p>
<pre><code class="language-ndjson">[&quot;https://example.com/john&quot;,&quot;https://example.com/birthDate&quot;,&quot;1991-01-20&quot;]
[&quot;https://example.com/birthDate&quot;,&quot;https://atomicdata.dev/datatypes/Datatype&quot;,&quot;https://atomicdata.dev/datatypes/dateTime&quot;]
[&quot;https://atomicdata.dev/datatypes/Datatype&quot;,&quot;https://atomicdata.dev/datatypes/Datatype&quot;,&quot;https://atomicdata.dev/datatypes/atomicURI&quot;]
</code></pre>
<p>Since all valid Atomic Data requires Property fields to resolve to Atomic Properties Classes, which are required to have an associated DataType...
We can safely say that the last atom in the example above (the one describing <code>https://atomicdata.dev/datatypes/Datatype</code>) will have to be pre
sent in all Schema Complete Atomic Graphs.</p>
<h1><a class="header" href="#tooling-for-atomic-data" id="tooling-for-atomic-data">Tooling for Atomic Data</a></h1>
<p>At this moment, no real tooling for Atomic Data exists.
Great tooling is required to make this a succes.
The following list is a set of ideas that we're likely to be working on.</p>
<h2><a class="header" href="#atomic-validator" id="atomic-validator">Atomic Validator</a></h2>
<p>Takes some Graph as an input, and validates its contents.
Could be useful for many purposes, and should be one of the first things to become available.
Not only should this parse Atomic-NDJSON, it should also make sure the URLs resolve and the DataTypes resolve.
Perhaps it should also return if non-standard Datatypes are being used, and if so, which ones.</p>
<h2><a class="header" href="#atomic-creator-cli" id="atomic-creator-cli">Atomic creator (CLI)</a></h2>
<p>A CLI tool for generating Atomic Data.
Should produce Atomic Mutations.</p>
<pre><code class="language-sh"># Create an atom
# atomic &lt;method&gt; &lt;subject&gt; &lt;property&gt; &lt;value&gt;
atomic add john birthdate 1991-01-20
# It's possible to use these keys instead of full URLs, as long as they are known locally,
# either in a local Atomic store a local prefixes file (e.g. ~/.ldget/prefixes)
# If the property is not used before, the CLI will ask for the required attributes (datatype, description) and create the Property
# The value will be parsed accordingly. If it does not meet the requirements, it wll not create the Atom.
# If everything is well, an Atomic Mutation will be sent to the Atomic Server
</code></pre>
<h2><a class="header" href="#atomic-server" id="atomic-server">Atomic server</a></h2>
<ul>
<li>Makes a graph available at some endpoint.</li>
<li>Responds to requests for created Atomic Resources (including Properties / DataTypes)</li>
<li>Offer useful query options (e.g. Triple Pattern Fragments)</li>
<li>Offers pub/sub functionality to clients that will want to listen to changes (Mutation Feed?)</li>
</ul>
<h2><a class="header" href="#atomizer-data-importer-and-conversion-kit" id="atomizer-data-importer-and-conversion-kit">Atomizer (data importer and conversion kit)</a></h2>
<ul>
<li>Import data from some data source (CSV / SQL / JSON / RDF), fill in the gaps (mapping / IRI creation / datatypes) an create new Atoms</li>
<li>Perhaps a CLI, library, GUI or a combination of all of these</li>
</ul>
<h2><a class="header" href="#libraries" id="libraries">Libraries</a></h2>
<p>The most important tooling for Atomic Data, are libraries.
Tools that developers use to fetch, manipulate and share Atomic Data inside their applications.
In this section, I'll create some rough API designs.</p>
<h3><a class="header" href="#atomic-js-javascript--typescript" id="atomic-js-javascript--typescript">Atomic-js (Javascript / Typescript)</a></h3>
<p>A JS compatible library, accessible as an NPM package is the most popular and developer friendly way to start.</p>
<p>Here's some pseudocode that indicates how it might be used:</p>
<pre><code class="language-js">import {createStore} from '@atomicdata';

const config = {
  // A URL to a TPF compatible endpoint where the data can be fetched
  tpfEndpoint: &quot;https://example.com/tpf&quot;,
  // A UTL to an Atomic Mutations endpoint where the client can subscribe to changes
  mutationsEndpoint: &quot;https://example.com/mutations&quot;,
  // A UTL to an Atomic Suggestions endpoint where the client can send suggested state changes
  sugestionsEndpoint: &quot;https://example.com/suggestions&quot;,
};

const store = createStore(config); // Initializes the store

// The `classInitializer` function takes an Atomic Class URI as its argument
// fetches the Class, its Properties and the DataTypes
// and returns a function that let's you create instances of that class
const personBuilder = await store.classInitializer(&quot;https://example.com/classes/Person&quot;);

// Create an instance of the Person Class
// An Atomic Suggestion is sent to the
const alice = await personBuilder({
  // The Subject field is optional, but recommended if you want to control its URL.
  // Otherwise, the Server will pick something
  subject: &quot;https://example.com/alice&quot;,
  // The IDE is aware of the existing keys and their acceptable values,
  // because a conversion from Atomic Classes and Properties
  // to typescript interfaces can be made automatically
  firstName: &quot;Alice&quot;,
  lastName: &quot;Anderson&quot;,
  bestFriend: &quot;https://example.com/Bob&quot;,
  birthDate: new Date(&quot;1991-01-20&quot;),
  // Since the URL in the key below can be fetched, and has a Property + Datatype, the IDE + the compiler can determine that 'true' is an acceptable type.
  &quot;https://example.com/someOtherProperty&quot;: true,
})

console.log(person.subject) //=&gt; Should return a newly created identifier

// Checks the store for the subject, and returns it.
// If it does not exists locally, it will fetch it first using the `tpfEndpoint`.
const alice = await store.get(&quot;https://example.com/alice&quot;)

// Because of the keys in Atomic Properties, we can use this dot syntax to traverse the graph and get a value
console.log(alice.bestFriend.firstName); // =&gt; &quot;Bob&quot;
</code></pre>
<p>I think a Developer Experience similar to the one above is essential for getting people to create linked data.
It should be incredibly easy, and this is what enables that.
However, realizing a library + IDE support as shown above is hard at the least, perhaps even impossible.
Theoretically, the information is accessible - but I'm not sure whether the IDE and the JS context (e.g. the Typescript compiler) can successfully see which shape is being returned by the <code>classInitializer</code> function.</p>
<h3><a class="header" href="#atomic-rs" id="atomic-rs">Atomic-rs</a></h3>
<p>Rust's compiler has strict type checking.
It also features a very flexible macro language, which could enable intuitive API designs for Atomic Data.
It could fetch the Properties and Classes at compile time, and convert these to</p>
<pre><pre class="playpen"><code class="language-rust">use atomic::{init_store}

fn main() {
  let mut graph = init_store();
  // TODO! Design a macro solution

}
</code></pre></pre>
<h2><a class="header" href="#atomic-browsser" id="atomic-browsser">Atomic Browsser</a></h2>
<p>A web-browser application that enables viewing, browsing, navigating Atomic Data.</p>
<h1><a class="header" href="#get-involved" id="get-involved">Get involved</a></h1>
<p>Atomic Data is an open specification, and that means that you're very welcome to share your thougts and help make this standard as good as possible.</p>
<p>Things you can do:</p>
<ul>
<li>Clone the <a href="https://github.com/ontola/atomic-data/">Book Repo</a> and read some of the inline comments, which might help start some discussions</li>
<li>Drop an <a href="https://github.com/ontola/atomic-data/issues">issue on Github</a> to share your suggestions or critisism</li>
<li>Join the <a href="https://discord.gg/ZspQv8">Discord server</a> for voice / text chat</li>
<li>Support our suggested <a href="https://www.w3.org/community/blog/2020/06/22/proposed-group-atomic-data-community-group/">W3C Community Group</a></li>
</ul>
<h2><a class="header" href="#authors" id="authors">Authors:</a></h2>
<ul>
<li>Joep Meindertsma (<a href="https://github.com/joepio/">joepio</a> from <a href="https://ontola.io/">Ontola.io</a>)</li>
</ul>
<h2><a class="header" href="#special-thanks-to" id="special-thanks-to">Special thanks to:</a></h2>
<ul>
<li>Thom van Kalkeren (who came up with many great ideas on how to work with RDF)</li>
<li>Tim Berners-Lee (for everything he did for linked data and the web)</li>
<li>Ruben Verborgh (for doing great work with RDF, such as the TPF spec)</li>
<li>All the other people who worked on the RDF specification</li>
<li>Pat McBennett (lots of valuable feedback on initial Atomic Data docs)</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-121994595-2', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
