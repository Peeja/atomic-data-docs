<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Atomic Data</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Documentation for the Atomic Data standard.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="atomic-data-overview.html"><strong aria-hidden="true">1.</strong> Atomic Data Overview</a></li><li class="chapter-item expanded "><a href="core/intro.html"><strong aria-hidden="true">2.</strong> Atomic Data Core</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="core/concepts.html"><strong aria-hidden="true">2.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="core/serialization.html"><strong aria-hidden="true">2.2.</strong> Serialization</a></li><li class="chapter-item expanded "><a href="core/querying.html"><strong aria-hidden="true">2.3.</strong> Querying</a></li></ol></li><li class="chapter-item expanded "><a href="schema/intro.html"><strong aria-hidden="true">3.</strong> Atomic Schema</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="schema/concepts.html"><strong aria-hidden="true">3.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="schema/base.html"><strong aria-hidden="true">3.2.</strong> Base Datatypes</a></li><li class="chapter-item expanded "><a href="schema/faq.html"><strong aria-hidden="true">3.3.</strong> FAQ</a></li></ol></li><li class="chapter-item expanded "><a href="mutations/intro.html"><strong aria-hidden="true">4.</strong> Atomic Mutations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="mutations/concepts.html"><strong aria-hidden="true">4.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="mutations/suggestions.html"><strong aria-hidden="true">4.2.</strong> Suggestions</a></li><li class="chapter-item expanded "><a href="mutations/versioning.html"><strong aria-hidden="true">4.3.</strong> Versioning</a></li></ol></li><li class="chapter-item expanded "><a href="interoperability/intro.html"><strong aria-hidden="true">5.</strong> Interoperability</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="interoperability/ipfs.html"><strong aria-hidden="true">5.1.</strong> Relation to IPFS</a></li><li class="chapter-item expanded "><a href="interoperability/rdf.html"><strong aria-hidden="true">5.2.</strong> Relation to RDF</a></li><li class="chapter-item expanded "><a href="interoperability/json.html"><strong aria-hidden="true">5.3.</strong> Relation to JSON</a></li></ol></li><li class="chapter-item expanded "><a href="core/graphs.html"><strong aria-hidden="true">6.</strong> Types of Atomic Graphs</a></li><li class="chapter-item expanded "><a href="tooling.html"><strong aria-hidden="true">7.</strong> Tooling</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="get-involved.html">Get involved</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Atomic Data</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/ontola/atomic-data" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#atomic-data-overview" id="atomic-data-overview">Atomic Data Overview</a></h1>
<p><em>Status: early draft, far from usable. <a href="get-involved.html">Feedback welcome</a>.</em></p>
<p>Atomic Data is a standard for modelling and exchanging data.
It uses links to connect pieces of data, and therefore makes it easier to connect datasets to each other - even when these datasets exist on seperate machines.
Atomic Data is heavily inspired by linked data, and all Atomic Data is valid linked data (RDF) but Atomic Data has some stricter requirements that aim to make it easier to use for developers.
Atomic Data is typed and extendible through <a href="schema/intro.html">Atomic Schema</a>, which means that you can define your own Classes, Properties and Datatypes.
Atomic Data has a standard for synchronizing data by communicating state changes, called <a href="mutations/intro.html">Atomic Mutations</a>.
You can use parts of Atomic Data seperately, but the standard is designed as a full data management package that makes it easier to create, share and use structured data on the web.</p>
<ul>
<li><a href="core/intro.html">Atomic Data Core</a>: the core model for typed, linked data</li>
<li><a href="schema/intro.html">Atomic Schema</a>: defining properties, datatypes and classes</li>
<li><a href="mutations/intro.html">Atomic Mutations</a>: sharing state changes, verifying changes and collaboration</li>
</ul>
<h1><a class="header" href="#atomic-data-core" id="atomic-data-core">Atomic Data Core</a></h1>
<p>The Atomic Data Core describes the fundamental data model of Atomic Data.
Before we dive into its concepts, we'll talk about why this standard is made in the first place.</p>
<h2><a class="header" href="#design-goals" id="design-goals">Design goals</a></h2>
<ul>
<li><strong>Typed</strong>: All valid Atomic data has an unambiguous, static datatype. Models expressed in Atomic Data can be mapped to programming langauge models, such as <code>structs</code> or <code>interfaces</code> in Typescript / Rust / Go.</li>
<li><strong>Semantic</strong>: Every data Atom and relation has a clear semantic meaning.</li>
<li><strong>Browseable</strong>: Data should explicitly link to other pieces of data, and these links should be followable.</li>
<li><strong>ORM-friendly</strong>: Navigate a <em>decentralized</em> graph by using dot.syntax, similar to how you navigate a JSON object in javascript.</li>
<li><strong>Open</strong>: Free to use, open source, no strings attached.</li>
<li><strong>Interoperable</strong>: Can easily and consitently be converted to other data formats (e.g. JSON, XML, and all RDF formats).</li>
<li><strong>Clear Ownership</strong>: The URL of the data shows who is in control of the data</li>
<li><strong>Extensible</strong>: Anyone can define their own data types and create Atoms with it.</li>
<li><strong>Mergeable</strong>: Any two sets of Atoms can be merged into a sinlge graph without any merge conflicts / name collissions.</li>
</ul>
<h2><a class="header" href="#motivation" id="motivation">Motivation</a></h2>
<p>Linked data (RDF / the semantic web) enables us to use the web as a large, decentralized graph database.
Using links everywhere in data has amazing merits: links remove ambiguity, they enable exploration, they enable connected datasets.
However, it's been almost 20 years since the introduction of linked data, and its adoption has been slow.
We believe this lack of growth has to do with <a href="core/../interoperability/rdf.html#why-these-changes">some problems that lie in the RDF data model</a>.
Atomic Data aims to take the best parts from RDF, and learn from the past to make a more developer-friendly, performant and reliable data model to achieve a truly linked web.</p>
<h1><a class="header" href="#atomic-data-core-concepts" id="atomic-data-core-concepts">Atomic Data Core: Concepts</a></h1>
<p>Understanding the Core concepts of Atomic Data are fundamental for reading the rest of the documentation.</p>
<h2><a class="header" href="#atomic-data" id="atomic-data">Atomic Data</a></h2>
<p>Atomic Data is a data format for representing information on the web.
It is a directed, labeled graph, similar to RDF.
It can be used to express any type of information, inlcuding personal data, vocabularies, metadata, documents, files and more.
Contrary to some other (labeled) graph data models, a relationship between two items (Resources) does not have attributes.</p>
<h2><a class="header" href="#atom-or-atomic-triple" id="atom-or-atomic-triple">Atom (or Atomic Triple)</a></h2>
<p>The smallest possible piece of <em>meaningful</em> data / information.
The model of an Atom is comparable with an RDF Triple / Statement (<a href="core/../interoperability/rdf.html">although there are imporant differences</a>).
An Atom consists of three values:</p>
<ul>
<li><strong><a href="core/concepts.html#Subject">Subject</a></strong>: the Thing that the atom is providing information about.</li>
<li><strong><a href="core/concepts.html#Predicate">Predicate</a></strong>: the property of the Thing that the atom is about.</li>
<li><strong><a href="core/concepts.html#Object">Object</a></strong>: the new piece of information about the Atom.</li>
</ul>
<p>Let's turn this sentence into Atoms:</p>
<p><code>Arnold, who's born on the 20th of Januari 1991, has a best friend named Britta.</code></p>
<pre><code class="language-ad3">[&quot;https://example.com/arnold&quot;,&quot;https://example.com/properties/bornAt&quot;,&quot;1991-01-20&quot;]
[&quot;https://example.com/arnold&quot;,&quot;https://example.com/properties/firstName&quot;,&quot;Arnold&quot;]
[&quot;https://example.com/arnold&quot;,&quot;https://example.com/properties/bestFriend&quot;,&quot;https://example.com/britta&quot;]
[&quot;https://example.com/britta&quot;,&quot;https://example.com/properties/firstName&quot;,&quot;Britta&quot;]
</code></pre>
<p>In the Atomic Data above, we have:</p>
<ul>
<li>four different Atoms (every line is an Atom)</li>
<li>two different Subjects: <code>https://example.com/arnold</code> and <code>https://example.com/britta</code>.</li>
<li>three different Predicates (<code>https://example.com/properties/bornAt</code>, <code>https://example.com/properties/firstName</code>, and <code>https://example.com/properties/bestFriend</code>)</li>
<li>four different Objects (<code>1991-0-20</code>, <code>Arnold</code>, <code>https://example.com/britta</code> and <code>Britta</code>)</li>
</ul>
<h2><a class="header" href="#subject" id="subject">Subject</a></h2>
<p>The Subject (or Atomic Subject) is the first part of an Atom.
It is the identifier that the rest of the Atom is providing information about.
It's a URL that points to the Resource.
The creator of the Subject MUST make sure that it resolves.
In other words: following / downloading the Subject link will provide you with all the Atoms about the Subject (see <a href="core/querying.html">Atomic Querying</a>.</p>
<h2><a class="header" href="#predicate" id="predicate">Predicate</a></h2>
<p>The Predicate (or Atomic Predicate) is the second part of an Atom.
It is a URL that points to an Atomic Property.
For example <code>https://example.com/createdAt</code> or <code>https://example.com/firstName</code>.</p>
<!-- Making this a requirement is what makes Atomic Data typed and semantic -->
<p>The Predicate MUST be a URL, and that URL MUST resolve to an Atomic Property.</p>
<h2><a class="header" href="#object" id="object">Object</a></h2>
<p>The Object (or Atomic Object) is the third part of an Atom.
Contrary to the Subject and Predicate values, the Object can be of any datatype.
This includes URLs, strings, integers, dates and more.</p>
<h2><a class="header" href="#graph" id="graph">Graph</a></h2>
<p>A Graph is a set of Atoms.
A Graph can describe various subjects, and may or may not be related.
Graphs can have several characteristics (Schema Complete, Valid, Closed)</p>
<h2><a class="header" href="#resource" id="resource">Resource</a></h2>
<p>A Resource is a set of Atoms (a Graph) that share the same Subject URL.
Every thing is Resource, such as the person &quot;Michael Jackson&quot;, or the abstract class &quot;Person&quot;.
All the concepts on this page are Resources.</p>
<h1><a class="header" href="#serialization-of-atomic-data" id="serialization-of-atomic-data">Serialization of Atomic Data</a></h1>
<p>Atomic Data is not necessarily bound to a single serialization format.
It's fundamentally a data model, and that's an important distinction to make.
We recommend you use <code>AtomicTriples</code>, which is specifically designed to be a simple, performant format for Atomic Data.</p>
<h2><a class="header" href="#atomictriples-ndjson-ad3" id="atomictriples-ndjson-ad3">AtomicTriples-ndjson (.ad3)</a></h2>
<p>Since the data model of Atomic Data is a bit simpler than RDF, serialization and parsing can be simpler as well.
In fact, a single Atom can be represented by an array of three strings, respectively representing the Subject, Predicate and Object.</p>
<p>It looks like this:</p>
<pre><code class="language-ndjson">[&quot;https://example.com/subject&quot;,&quot;https://example.com/predicate&quot;,&quot;some object&quot;]
[&quot;https://example.com/subject&quot;,&quot;https://example.com/otherProperty&quot;,&quot;https://example.com/somethingelse&quot;]
</code></pre>
<p>NDJSON has some important benefits:</p>
<ul>
<li>
<p>It visually represents the underlying datamodel (the Atom)</p>
</li>
<li>
<p>It can be streaming parsed, i.e. before the entire document is loaded. That is not possible with regular JSON.</p>
</li>
<li>
<p>NDJSON parsers are everywhere</p>
</li>
<li>
<p>Modern browers have highly performant (ND)JSON parsing, which means that it's <em>fast</em> in one of the most imporant contexts: the browser.</p>
</li>
<li>
<p><em>Mime type (not registered yet!): <code>application/ad3+x-ndjson; charset=utf-8</code></em></p>
</li>
<li>
<p><em>File name extention: <code>.ad3</code></em></p>
</li>
</ul>
<p>Disclaimer: note that Atomic-NDJSON is useful for communicating <em>current state</em>, but not for <em>state changes</em>.</p>
<h2><a class="header" href="#atomicdoubles-ndjson-ad2" id="atomicdoubles-ndjson-ad2">AtomicDoubles-ndjson (.ad2)</a></h2>
<p>AtomicDoubles is similar to Atomic3, with one exception: the subject is left out.
This is useful in at least two scenarios:</p>
<ul>
<li>The Subject is not yet known (for example, because it still has to be determined by some server or hash function).</li>
<li>The Subject is already known by the client, and leaving it out saves data.</li>
</ul>
<pre><code class="language-ndjson">[&quot;https://example.com/predicate&quot;,&quot;some object&quot;]
[&quot;https://example.com/otherProperty&quot;,&quot;https://example.com/somethingelse&quot;]
</code></pre>
<ul>
<li><em>Mime type (not registered yet!): <code>application/ad2+x-ndjson; charset=utf-8</code></em></li>
<li><em>File name extention: <code>.ad2</code></em></li>
</ul>
<h2><a class="header" href="#rdf-serializatinon-formats" id="rdf-serializatinon-formats">RDF serializatinon formats</a></h2>
<p>Because of the similarties with RDF, RDF serialization formats can be used to communicate and store Atomic Data, such as N-Triples, Turtle, HexTuples or JSON-LD.
<em>However</em>, keep in mind that RDF users will expect other things from their data.
Read more about the various existing formats and their respective merits <a href="https://ontola.io/blog/rdf-serialization-formats/">here</a>.</p>
<h2><a class="header" href="#future-formats" id="future-formats">Future formats</a></h2>
<p>In the future, new serialization formats will be introduced.
For example, a fully optimized binary serialization format would make sense.</p>
<h1><a class="header" href="#querying-atomic-data" id="querying-atomic-data">Querying Atomic Data</a></h1>
<p>There are multiple ways of getting Atomic Data into some system:</p>
<ul>
<li>Subject Fetching requests a single subject right from its source</li>
<li>Triple Pattern Fragments allows querying for specific (combinations of) Subject, Predicate and Object values.</li>
<li>SRARQL is a powerful Query language for traversing graphs</li>
</ul>
<h2><a class="header" href="#subject-fetching-http" id="subject-fetching-http">Subject fetching (HTTP)</a></h2>
<p>The simplest way of getting Atomic Data, is by sending an HTTP GET request to the subject URL.
Set the <code>Content-Type</code> header to an Atomic Data compatible mime type, such as <code>application/atomic+x-ndjson</code>.</p>
<pre><code class="language-HTTP">GET https://example.com/myResource HTTP/1.1
Content-Type: application/atomic+x-ndjson
</code></pre>
<p>The server should respond with all the Atoms of which the requested URL is the subject:</p>
<pre><code class="language-HTTP">HTTP/1.1 200 OK
Content-Type: application/atomic+x-ndjson
Connection: Closed

[&quot;https://example.com/myResource&quot;,&quot;https://example.com/properties/name&quot;,&quot;My awesome resource!&quot;]
</code></pre>
<h2><a class="header" href="#triple-pattern-fragments" id="triple-pattern-fragments">Triple Pattern Fragments</a></h2>
<p><a href="https://linkeddatafragments.org/specification/triple-pattern-fragments/">Triple Pattern Fragments</a> is an interface for querying RDF.
It works great for Atomic Data as well.</p>
<p>An HTTP implementation of a TPF endpoint might accept a GET request to a URL such as this:</p>
<p><code>http://example.org/tpf?subject={subject}&amp;predicate={predicate}&amp;object={object}</code></p>
<p>Make sure to URL encode the <code>subject</code>, <code>predicate</code>, <code>object</code> strings.</p>
<p>For example, let's search for all Atoms where the object is <code>test</code>.</p>
<pre><code class="language-HTTP">GET https://example.com/tpf?object=&quot;test&quot; HTTP/1.1
Content-Type: application/atomic+x-ndjson
</code></pre>
<pre><code class="language-HTTP">HTTP/1.1 200 OK
Content-Type: application/atomic+x-ndjson
Connection: Closed

[&quot;https://example.com/myResource&quot;,&quot;https://example.com/properties/name&quot;,&quot;test&quot;]
</code></pre>
<h2><a class="header" href="#bulk-api" id="bulk-api">Bulk API</a></h2>
<p><a href="https://github.com/ontola/bulk-api">Bulk-API</a> is an (currently still closed) in-development specification for asking for multiple Subjects in one request.
This is especially useful in browser clients that traverse the graph iteratively, and HTTP/2 is not an option.</p>
<h2><a class="header" href="#spaqrl" id="spaqrl">SPAQRL</a></h2>
<p><a href="https://www.w3.org/TR/rdf-sparql-query/">SPARQL</a> is a powerful RDF query language.
Since all Atomic Data is also valid RDF, it is possible to query Atomic Data using SPARQL.</p>
<h1><a class="header" href="#atomic-schema" id="atomic-schema">Atomic Schema</a></h1>
<p>Atomic Schema is the standard for specifying classes, properties and datatypes in Atomic Data.
You can compare it to what XSD is for XML.</p>
<p>This section will define various Classes, Properties and Datatypes (discussed in <a href="schema/../core/concepts.html">Atomic Core: Concepts</a>).</p>
<!-- Making this a requirement is what makes Atomic Data typed and semantic -->
<p>Some of these Classes, Properties and Datatypes are <em>optional</em> to use, but</p>
<h2><a class="header" href="#design-goals-1" id="design-goals-1">Design Goals</a></h2>
<ul>
<li><strong>Typed</strong>: Every Atom of data has a clear datatype.</li>
<li><strong>IDE-friendly</strong>: Every property has a simple short key representation (useful in text-based context) that maps to a URL that contains more information.</li>
<li><strong>Human readable</strong>: All Datatypes should have a human-readable represenatation.</li>
<li><strong>Performant</strong>: Datatypes can have a binary represenatation for optimal storage, communication, serialization and parsing efficiency.</li>
<li><strong>Extensible</strong>: Anybody can create their own Datatypes, Properties and Classes.</li>
<li><strong>Accessible</strong>: Support for languages, easily translateable.</li>
<li><strong>Atomic</strong>: All the design goals of Atomic Data itself also apply here.</li>
<li><strong>Self-describing</strong>: Atomic Schema is to be described as Atomic Data using Atomic Schema.</li>
</ul>
<h1><a class="header" href="#atomic-schema-concepts" id="atomic-schema-concepts">Atomic Schema: Concepts</a></h1>
<p>In short, Atomic Schema works like this:</p>
<ul>
<li>The Predicate value in an Atom links to a Property. It is important that these resolve.</li>
<li>This Property tells something about its semantic meaning, and links to a Datatype.</li>
<li>The Datatype tells</li>
<li>A Resource <em>could</em> have one or more classes, which <em>could</em> provide information about which Properties are expected or required.</li>
</ul>
<h2><a class="header" href="#property" id="property">Property</a></h2>
<p><em>URL: <code>https://atomicdata.dev/classes/Class</code></em></p>
<p>A Property is an abstract type of Resource that describes the relation between a subject and an object.
A Property provides some semantic information about the relationship (in its <code>description</code>), it provides a shorthand (the <code>key</code>) and it links to a Datatype.</p>
<p>Properties:</p>
<ul>
<li><code>key</code> - (required, Slug) the shortname for the property, used in dot syntax. String with a-Z characters only. Case sensitive.</li>
<li><code>description</code> - (optional, <a href="schema/base.html#Langstring">Langstring</a>) the semantic meaning of the.</li>
<li><code>datatype</code> - (required, Datatype) a URI to an Atomic Datatype, which defines what the datatype should be of the Object in an Atom where the Predicate is the</li>
<li><code>classtype</code> - (optional, Class) if the <code>datatype</code> is an Atomic URI, the <code>classtype</code> defines which class(es?) is (are?) acceptable.</li>
</ul>
<pre><code class="language-ndjson">[&quot;https://example.com/properties/createdAt&quot;,&quot;https://atomicdata.dev/property/key&quot;,&quot;createdAt&quot;]
[&quot;https://example.com/properties/createdAt&quot;,&quot;https://atomicdata.dev/property/datatype&quot;,&quot;https://atomicdata.dev/datatype/datetime&quot;]
</code></pre>
<h2><a class="header" href="#datatype" id="datatype">Datatype</a></h2>
<p><em>URL: <code>https://atomicdata.dev/classes/Datatype</code></em></p>
<p>A Datatype specifies how an <code>Object</code> value should be interpreted.</p>
<ul>
<li><code>description</code> - (required, langstring) how the datatype functions.</li>
<li><code>stringSerialization</code> - (required, langstring) how the datatype should be parsed / serialized as an UTF-8 string</li>
<li><code>stringExample</code> - (required, string) an example stringSerialization example value that should be parsed correclty</li>
<li><code>binarySerialization</code> - (optional) how the datatype should be parsed / serialized as a byte array.</li>
<li><code>binaryExample</code> - (optional) an example stringSerialization that should be parsed correclty. Should have the same contents as the stringExample. Required if binarySerialization is present on the DataType.</li>
</ul>
<h2><a class="header" href="#class" id="class">Class</a></h2>
<p><em>URL: <code>https://atomicdata.dev/classes/Class</code></em></p>
<p>A Class is an abstract type of Resource, such as <code>Person</code>.
It is convention to use an Uppercase in its URI.
A Resource can have zero to many Classes, so this might be different from most data works.</p>
<p>Properties:</p>
<ul>
<li><code>key</code> - (required, Slug) a short string shorthand.</li>
<li><code>description</code> - (required, langstring) human readable explanation of what the Class represents.</li>
<li><code>requires</code> - (optional, ResourceArray) a list of Properties that are required. If absent, none are required.</li>
<li><code>recommends</code> - (optional, ResourceArray) a list of Properties that are recommended.</li>
</ul>
<!-- Maybe remove this next one? -->
<!-- - `disallowedProperties` - (optional, ResourceArray) a list of Properties that are not allowed.  If absent, all are allowed. -->
<!-- What are the consequences of this? How to deal with this field if there are more classes in a Subject? -->
<!-- - `allowedProperties` - (optional, ResourceArray) a list of Properties that are allowed. If absent, none are required. -->
<p>Example:</p>
<pre><code class="language-ndjson">[&quot;https://example.com/classes/Person&quot;,&quot;https://atomicdata.dev/properties/isA&quot;,&quot;Class&quot;]
[&quot;https://example.com/classes/Person&quot;,&quot;https://atomicdata.dev/properties/datatype&quot;,&quot;https://atomicdata.dev/datatypes/datetime&quot;]
</code></pre>
<p>Incoming Properties:</p>
<ul>
<li><code>hasClass</code> - A property that any resource</li>
</ul>
<h1><a class="header" href="#atomic-schema-base-datatypes" id="atomic-schema-base-datatypes">Atomic Schema: Base Datatypes</a></h1>
<p>The Atomic Base Datatypes consist of some of the most commonly used <a href="schema/concepts.html#Datatype">Datatypes</a>.</p>
<h2><a class="header" href="#slug" id="slug">Slug</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/slug</code></em></p>
<p>A string with a limited set of allowed characters, used in IDE / Text editor context.</p>
<h2><a class="header" href="#atomic-uri" id="atomic-uri">Atomic URI</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/atomicURI</code></em></p>
<p>A URL that should resolve to an <a href="schema/../core/concepts.html#Resource">Atomic Resource</a>.</p>
<h2><a class="header" href="#uri" id="uri">URI</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/URI</code></em></p>
<p>A Uniform Resource Identifier, preferably a URL (i.e. an URI that can be fetched).
Could be HTTP, HTTPS, or any other type of schema.</p>
<h2><a class="header" href="#string" id="string">String</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/string</code></em></p>
<p>UTF-8 String, no max character count.
Newlines use backslash escaped <code>\n</code> characters.
Should not contain language specific data, use a <code>langstring</code> instead.</p>
<p>e.g. <code>String time! \n Second line!</code></p>
<h2><a class="header" href="#langstring" id="langstring">Langstring</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/langstring</code></em></p>
<!--
So this is something I'm having serious doubts on.
It seems so verbose and hard to parse.
However, the underlying problem is kind of tough: we want <subject> <predicate> combination uniqueness...
... but we also want to have multilingual strings that can be added later.
-->
<p>Array of special UTF-8 Strings.
Each element of the Array starts with a language string code, followed by a newline.</p>
<p>e.g. <code>[&quot;en-US\nHi there&quot;],[&quot;nl-NL\nHallo daar&quot;]</code></p>
<h2><a class="header" href="#integer" id="integer">Integer</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/integer</code></em></p>
<p>Signed Integer, max 64 bit.
Max value: <a href="https://en.wikipedia.org/wiki/9,223,372,036,854,775,807"><code>9223372036854775807</code></a></p>
<p>e.g. <code>-420</code></p>
<h2><a class="header" href="#boolean" id="boolean">Boolean</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/boolean</code></em></p>
<p>True or false, one or zero.</p>
<p><strong>String serialization</strong></p>
<p><code>true</code> or <code>false</code>.</p>
<p><strong>Binary serialization</strong></p>
<p>Use a single bit one boolean.</p>
<p>1 for <code>true</code>, or 0 for <code>false</code>.</p>
<h2><a class="header" href="#datetime" id="datetime">Datetime</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/dateTime</code></em></p>
<p>ISO 8601 encoded string.</p>
<p>e.g. <code>2020-06-11</code></p>
<h2><a class="header" href="#mimefile" id="mimefile">MIMEFile</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/mimeFile</code></em></p>
<p>Any type of file, starting with its <a href="https://www.iana.org/assignments/media-types/media-types.xhtml">mime type</a>
Although MIME types <a href="https://stackoverflow.com/a/29019569/2502163">often don't exist in your OS</a>, specifying them seems like a good idea.</p>
<p><strong>String serialization</strong></p>
<p>Start with the mimetype string, do a newline <code>\n</code> and continue with the UTF-8 stringified data.</p>
<ul>
<li>e.g. <code>application/text\nOh hi mark</code></li>
<li>e.g. <code>text/html\n&lt;html&gt;&lt;p&gt;oh, hi mark&lt;/p&gt;&lt;/html&gt;</code></li>
</ul>
<p><strong>Binary serialization</strong></p>
<h2><a class="header" href="#resourcearray" id="resourcearray">ResourceArray</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/resourceArray</code></em></p>
<p>Sequential, ordered list of Atomic URIs.
Serialized as a JSON array with strings.
Note that other types of arrays are not included in this spec, but can be perfectly valid.</p>
<ul>
<li>e.g. <code>[&quot;https://example.com/1&quot;, &quot;https://example.com/1&quot;]</code></li>
</ul>
<h2><a class="header" href="#" id=""></a></h2>
<h1><a class="header" href="#atomic-schema-faq" id="atomic-schema-faq">Atomic Schema FAQ</a></h1>
<h2><a class="header" href="#how-do-i-create-a-property-that-supports-multiple-datatypes" id="how-do-i-create-a-property-that-supports-multiple-datatypes">How do I create a Property that supports multiple Datatypes?</a></h2>
<p>A property only has one single Datatype.
However, feel free to create a new kind of Datatype that, in turn, refers to other Datatypes.
Perhaps this should be part of the Atomic Base Datatypes.</p>
<h2><a class="header" href="#how-should-a-client-deal-with-dot-syntax-key-collisions" id="how-should-a-client-deal-with-dot-syntax-key-collisions">How should a client deal with dot syntax key collisions?</a></h2>
<p>Atomic Data guarantees <code>&lt;subject&gt; &lt;predicate&gt;</code> uniqueness, but when you're working on Atomic Data in an IDE / text editor, you're likely to use the <code>key</code> of the <code>Property</code>.</p>
<p>For example:</p>
<pre><code class="language-ndjson">[&quot;https://example.com/people/123&quot;, &quot;https://example.com/name&quot;, &quot;John&quot;]
[&quot;https://example.com/people/123&quot;, &quot;https://somepage.example.com/name&quot;, &quot;John&quot;]
</code></pre>
<p>Let's assume that <code>https://somepage.example.com/name</code> and <code>https://example.com/name</code> are Properties that have a <code>key</code> with the object <code>name</code>.</p>
<pre><code class="language-ndjson">[&quot;https://somepage.example.com/name&quot;]
</code></pre>
<p>This</p>
<h2><a class="header" href="#atomic-data-uses-a-lot-of-links-how-do-you-deal-with-links-that-dont-work" id="atomic-data-uses-a-lot-of-links-how-do-you-deal-with-links-that-dont-work">Atomic Data uses a lot of links. How do you deal with links that don't work?</a></h2>
<ol>
<li>Use URIs schemes that use content adressing, such as IPFS URIs.</li>
</ol>
<h2><a class="header" href="#whats-a-uri-and-whats-a-url" id="whats-a-uri-and-whats-a-url">What's a URI, and what's a URL?</a></h2>
<p>URI stands for Unique Resource Identifier</p>
<h1><a class="header" href="#atomic-mutations" id="atomic-mutations">Atomic Mutations</a></h1>
<p>Atomic Mutations is a standard for communicating state changes of <a href="mutations/../core/intro.html">Atomic Data</a>.
It is the part of Atomic Data that is concerned with writing, editing and updating.</p>
<p><em>Disclaimer: This part of the draft spec lacks even more clarity than the others, and is constantly moving.</em></p>
<h2><a class="header" href="#design-goals-2" id="design-goals-2">Design goals</a></h2>
<ul>
<li><strong>Event sourced</strong>: Store State changes, as well as the current state. This enables versioning, history playback, undo, audit controls, and more.</li>
<li><strong>Traceable origin</strong>: Every state change should be traceable to an actor and a point in time.</li>
<li><strong>Verifiable</strong>: Have cryptographic proof for every state change.</li>
<li><strong>Decentralized</strong>: Can be used in P2P networks to send mutations from device to device.</li>
<li><strong>Extendible</strong>: The methods are not fixed, and can be added by anyone.</li>
<li><strong>Streamable</strong>: The state changes could be used in streaming context, e.g. a client app that reads data that changes every second.</li>
<li><strong>Atomic</strong>: All the Atomic Data design goals also apply here.</li>
</ul>
<h2><a class="header" href="#motivation-1" id="motivation-1">Motivation</a></h2>
<p>So many problems that confine data exchange are the result of thinking in current-state exchange.
State synchronization is often an afterthought, and ... TODO!</p>
<p>Keeping track of where data comes from is essential to knowing whether you can trust it - whether you consider it to be true.
When you want to persist data, that quickly becomes bothersome.
Atomic Data and Atomic Mutations aim to make this easier by using cryptography for ensuring data comes from some particular source, and is therefore trustworthy.</p>
<h2><a class="header" href="#in-short" id="in-short">In short</a></h2>
<ul>
<li><a href="mutations/concepts.html">Atomic Mutations</a> are small pieces of information that descibe how a Resource was changed. Think of these as Commits which are</li>
<li><a href="mutations/concepts.html">Atomic Suggestions</a> are small pieces of information that suggest how a Resource should be changed.</li>
</ul>
<h1><a class="header" href="#atomic-mutations-concepts" id="atomic-mutations-concepts">Atomic Mutations: Concepts</a></h1>
<h2><a class="header" href="#mutation" id="mutation">Mutation</a></h2>
<p>The smallest possible piece of a state change.
A mutation describes how an Resource should be updated.
An Atomic Mutation consists of a:</p>
<ul>
<li><code>subject</code> - the Thing that the atom is providing information about. (must be a URI to an Atomic Thing)</li>
<li><code>predicate</code> - the property of the Thing that the atom is about. (must be a URI to an Atomic Property)</li>
<li><code>object</code> - the new piece of information about the Atom (can be any datatype, as long as its defined by the predicate)</li>
<li><code>method</code> - How the resource needs to be updated using the Atom. If empty, just replace the current state.</li>
<li><code>hash</code> - The <a href="mutations/versioning.html#Hashing">IPFS URL</a> of the updated version of the resource. If this does not match with your resource, the Mutation is faulty. The hash can be empty if it is sent in</li>
<li><code>date</code> - A timestamp of when the mutation was created.</li>
</ul>
<!-- Should it have an actor?  -->
<ul>
<li><code>actor</code> - A timestamp of when the mutation was created.</li>
</ul>
<h2><a class="header" href="#ledger" id="ledger">Ledger</a></h2>
<p>A Ledger is an (append-only) log of Mutations.</p>
<p>TODO!</p>
<h2><a class="header" href="#commit" id="commit">Commit</a></h2>
<p>A Commit is a set of Mutations, made by some Actor</p>
<p>TODO!</p>
<h2><a class="header" href="#serialization-with-atomicmutations-ndjson" id="serialization-with-atomicmutations-ndjson">Serialization with AtomicMutations-ndjson</a></h2>
<p>Altough Mutations can be communicated with</p>
<p>Work in progress, see <a href="https://github.com/ontola/linked-delta">linked-delta</a>.</p>
<pre><code class="language-ndjson">[&quot;https://example.com/john&quot;, &quot;https://example.com/properties/lastName&quot;, &quot;Mc'Lovin&quot;, &quot;https://purl.org/linked-delta/add&quot;, &quot;AEF1245612F3&quot;]
</code></pre>
<h2><a class="header" href="#streaming-pubsub" id="streaming-pubsub">Streaming (pub/sub)</a></h2>
<p>We're using HexTuples-NDJSON, since that allows for streaming parsing of mutations.</p>
<p>TODO! Something about endpoints / protocol for pub/sub.</p>
<h2><a class="header" href="#base-methods" id="base-methods">Base Methods</a></h2>
<p>See <a href="http://purl.org/linked-delta">linked-delta</a></p>
<h1><a class="header" href="#atomic-suggestions" id="atomic-suggestions">Atomic Suggestions</a></h1>
<p>Atomic Suggestions is a standard that enables decentralized collaboration on resources.
It's basically Git for linked data.</p>
<!-- It describes how proposals for data changes -->
<h2><a class="header" href="#design-goals-3" id="design-goals-3">Design goals</a></h2>
<ul>
<li><strong>Asynchronous collaboration</strong>: Various users can work on the same thing at the same time.</li>
<li><strong>Branching &amp; merging</strong>: Issues that result from async changes (merge conflicts) can be resolved.</li>
</ul>
<h2><a class="header" href="#concepts" id="concepts">Concepts</a></h2>
<h3><a class="header" href="#suggestion" id="suggestion">Suggestion</a></h3>
<!-- Perhaps suggestions are too similar to Mutations, and should be merged into a single concept? -->
<p>A Suggestion is a (set of?) Mutation(s?) that is proposed to be appended to some Ledger.
The important difference between a Suggestion and a Mutation, is that a Mutation has been verified, signed and approved by the Controller.</p>
<h3><a class="header" href="#controller" id="controller">Controller</a></h3>
<p>The actor (person / organization) that is in control of a specific Resource and its mutations.</p>
<h3><a class="header" href="#inbox" id="inbox">Inbox</a></h3>
<p>An Inbox represents an endpoint that accepts incoming Suggestions.
It's similar to an e-mail inbox.</p>
<h1><a class="header" href="#atomic-data-versioning" id="atomic-data-versioning">Atomic Data Versioning</a></h1>
<p>When Atomic Mutations are applied to some Resource, the resource will change.
However, its identifier (the Subject) will often remain the same.</p>
<ul>
<li>Versioned representations should provide a link to the authority that might update it, and a link to where the latest version can be found.</li>
<li>The latest version should have a link to its permanent verison.</li>
<li>Should <a href="mutations/../interoperability/ipfs.html">IPFS</a> content-hash URLs be used for Versioned resources?</li>
</ul>
<h2><a class="header" href="#hashing" id="hashing">Hashing</a></h2>
<ul>
<li>Serialize all Atoms of the Subject (the entire Resource) as Atomic-NDJSON</li>
<li>Sort all lines (every atom) alphabetically</li>
</ul>
<h1><a class="header" href="#interoperability-relation-to-other-technology" id="interoperability-relation-to-other-technology">Interoperability: Relation to other technology</a></h1>
<p>Atomic data is designed to be highly interoperable.</p>
<h2><a class="header" href="#data-formats" id="data-formats">Data formats</a></h2>
<p>It is possible to convert Atomic to many types of serialization formats.</p>
<ul>
<li><a href="interoperability/rdf.html">RDF</a>: some RDF can be automatically converted into valid Atomic data.</li>
<li><a href="interoperability/json.html">JSON</a>: JSON requires a mapping to Atomic Properties, and explicit</li>
</ul>
<h2><a class="header" href="#protocols" id="protocols">Protocols</a></h2>
<ul>
<li><a href="interoperability/ipfs.html">IPFS</a>: Content-based adressing to prevent 404s and centralization</li>
</ul>
<h1><a class="header" href="#atomic-data-and-ipfs" id="atomic-data-and-ipfs">Atomic Data and IPFS</a></h1>
<h2><a class="header" href="#what-is-ipfs" id="what-is-ipfs">What is IPFS</a></h2>
<p>IPFS (the InterPlanetery File System) is a standard that enables content-based identifiers.
Intead of using an HTTP URL like <code>http://example.com/helloworld</code>, it uses the IPFS scheme, such as <code>ipfs:QmX6j9DHcPhgBcBtZsuRkfmk2v7G5mzb11vU9ve9i8vDsL</code>.
It identifies things based on their unique content hash (the long, seemingly random string).
This simple idea (plus some not so simple network protocols) allows for decentalized, temper-proof storage of data.
This fixes some issues with HTTP that are related to its centralized philosophy: no more 404s!</p>
<h2><a class="header" href="#why-is-ipfs-especially-interesting-for-atomic-data" id="why-is-ipfs-especially-interesting-for-atomic-data">Why is IPFS especially interesting for Atomic Data</a></h2>
<p>Atomic Data is highly dependent on the availability of Resources, especially Properties and Datatypes.
These resources are meant to be re-used a lot, and that would make everything expensive.</p>
<h2><a class="header" href="#considerations-using-ipfs-urls" id="considerations-using-ipfs-urls">Considerations using IPFS URLs</a></h2>
<p>They are static, their contents can never change.
This is great for some types of data, but horrible for others.
If you're describing a time-dependent thing (such as a person's job),
If you're describing personal, private information, its also a bad idea to use IPFS, because it's designed to be permanent.
Also, IPFS is not as fast as HTTP - at least for now.</p>
<h2><a class="header" href="#example-of-atomic-data-on-ipfs" id="example-of-atomic-data-on-ipfs">Example of Atomic Data on IPFS</a></h2>
<p>Here's an example, serialized to Atomic-NDJSON:</p>
<p>[https://ipfs.io/ipfs/QmX6j9DHcPhgBcBtZsuRkfmk2v7G5mzb11vU9ve9i8vDsL]</p>
<pre><code class="language-ndjson">[&quot;https://atomicdata.dev/helloworld&quot;,&quot;https://atomicdata.dev/properties/description&quot;,&quot;Hello world!&quot;]
</code></pre>
<h2><a class="header" href="#atomic-data-and-ipld" id="atomic-data-and-ipld">Atomic Data and IPLD</a></h2>
<p>IPLD (not IPFS) stands for InterPlanetery Linked Data, but is not related to RDF.
The scope seems fundamentally different from RDF, too, but I have to read more about this.
TODO!</p>
<h1><a class="header" href="#how-does-atomic-data-relate-to-rdf" id="how-does-atomic-data-relate-to-rdf">How does Atomic Data relate to RDF?</a></h1>
<p>RDF is the original data model behind linked data.
It is also the forerunner of Atomic Data, and is therefore highly similar in its philosophy and model.
Both heavily rely on using URLs, and both have a fundamentally simple and uniform model for data statements.
Both view the web as a single, connected graph database.
Because of that, Atomic Data is also highly compatible with RDF - <strong>all Atomic Data can be converted into valid RDF</strong>.
Atomic Data can be thought of as a <strong>more constrained, type safe version of RDF</strong>.
However, it does differ in some fundamental ways.</p>
<ul>
<li>Atomic only allows those who control a resource's <code>subject</code> URL endpoint to edit the data. This means that you can't add triples about something that you don't control.</li>
<li>Atomic requires URL values in its <code>subjects</code> and <code>predicates</code>, which means that they should be resolveable.</li>
<li>Atomic has no seperate <code>datatype</code> field, but it requires that <code>Properties</code> (the resources that are shown when you folllow a <code>predicate</code> value) specify a datatype</li>
<li>Atomic has no seperate <code>language</code> field, but it does support language strings as a Datatype in Properties.</li>
<li>Atomic has a native Event (state changes) model (<a href="interoperability/../mutations/intro.html">Atomic Mutations</a>), which enables communication of state changes</li>
<li>Atomic has a native Schema model (<a href="interoperability/../schema/intro.html">Atomic Schema</a>), which helps developers to know what data types they can expect (string, integer, link, array)</li>
<li>Atomic does not support <code>graph</code> fields in statments.</li>
<li>Atomic does not support <code>blank nodes</code>.</li>
<li>Atomic does not support having multiple statements with the same <code>&lt;subject&gt; &lt;predicate&gt;</code>, every combination should be unique.</li>
</ul>
<h2><a class="header" href="#why-these-changes" id="why-these-changes">Why these changes?</a></h2>
<p>I love RDF, and have been working with it for quite some time now.
Using URIs (and moreso URLs, which are URIs that can be fetched) for everything is a great idea, since it helps with interoperability and enables truly decentralized knowledge graphs.
However, some of the characteristics of RDF might have contributed to its relative lack of adoption.</p>
<ul>
<li>Having both a <code>datatype</code> and a <code>predicate</code> value can lead to confusing situations. For example, the <a href="https://schema.org/dateCreated"><code>schema:dateCreated</code></a> Property requires an ISO DateTime string (according to the schema.org definition), but using a value <code>true</code> with an <code>xsd:boolean</code> datatype results in perfectly valid RDF. This means that client software using triples with a <code>schema:dateCreated</code> predicate cannot safely assume that its value will be a DateTime. So if the client wants to use <code>schema:dateCreated</code> values, the client must also specify which type of data it expects, check the datetype field of every Atom and provide logic for when these don't match.</li>
<li>Using full URI strings as keys (in predicates) results in clunky Developer Experience, compared to the short strings that developers are used to in pretty much all languages and data formats. Adding a required / tightly integrated key mapping (from long URLs to short, simple strings) in Atomic Properties solves this issue, and provides developers a way to write code like this: <code>someAtomicPerson.bestFriend.name =&gt; &quot;Britta&quot;</code>. Although the RDF ecosystem does have some solutions for this (@context objects in JSON-LD, @prefix mappings, the @ontologies library), these prefixes are not defined in Properties themselves and therefore are defined locally only, which means that developers have to manually map them most of the time.</li>
<li>RDF lacks a clear solution for dealing with <a href="https://ontola.io/blog/ordered-data-in-rdf/">ordered data</a>, resulting in confusion when developers have to create lists of content. Adding an Array data type as a base data type helps solve this.</li>
<li>There is no integrated standard for communicating state changes (although <a href="https://github.com/ontola/linked-delta">linked-delta</a> and <a href="https://afs.github.io/rdf-delta/">rdf-delta</a> do exist)</li>
<li>RDF allows that domain A creates statements about domain B. This means that someone using RDF data about domain B cannot know that domain B is actually the source of the data. Knowing <em>where data comes from</em> is one of the great things about URIs, but RDF does not require that you can think of subjects as the source of data. Many subjects in RDF don't actually resolve to all the known triples of the statement. It would make the conceptual model way simpler if statements about a subject could only be made from the source of the domain owner of the subject.</li>
<li>RDF allows any type of URIs for <code>subject</code> and <code>predicate</code> value, which means they can be URLs, but don't have to be. This means they don't always resolve, or even function as locators. The links don't work, and that restricts how useful the links are. Atomic Data takes a different approach: these links MUST Resolve. Requiring that is part of what enables the type system of Atomic Schema.</li>
</ul>
<p>Besides these technical reasons about the RDF model, I think that there are more reasons to start with a new concept and give it a new name:</p>
<ul>
<li>The RDF documentation is intimidating for beginners. When trying to understand RDF, you're likely to traverse. All Core / Schema URLs should resolve to simple, clear explanations with both examples and machine readable definitions.</li>
<li>There is a lack of learning resources that provide a clear, complete answer to the lifecycle of RDF data: modelling data, making data, hosting it, fetching it, updating it. Atomic Data aims to provide an opinionated answer to all of these steps.</li>
<li>The Semantic Web community has had a lot of academic attention from formal logic departments, resulting in a highly developed standard for knowledge modelling: the Web Ontology Language (OWL). While this is mostly great, its open-world philosophy and focus on reasoning abilities can confuse developers who are simply looking for a simple way to share models in RDF.</li>
</ul>
<!-- - Re-using predicate URIs in new contexts can be result in unclear descriptions, since the meaning of predicates can be very class-dependent. For examle, a `name` for a Person means something else than a `name` for a  -->
<h2><a class="header" href="#convert-atomic-data-to-rdf" id="convert-atomic-data-to-rdf">Convert Atomic data to RDF</a></h2>
<p>Since all Atomic Data is also valid RDF, it's trivial to convert / serialize Atoms to RDF.</p>
<ul>
<li>In conversion to RDF, convert <code>langstring</code> objects to Literals with an <code>xsd:string</code> datatype</li>
</ul>
<h2><a class="header" href="#convert-rdf-to-atomic-data" id="convert-rdf-to-atomic-data">Convert RDF to Atomic Data</a></h2>
<ul>
<li>All <code>predicates</code> SHOULD resolve to Atomic Properties, and these SHOULD have a <code>datatype</code>. This means that the <code>datatype</code> in the original RDF statement can be dropped.</li>
<li>Literals with a <code>language</code> tag are converted to the <code>atomic:langstring</code> type. TODO! How to fis</li>
</ul>
<h1><a class="header" href="#how-does-atomic-data-relate-to-json" id="how-does-atomic-data-relate-to-json">How does Atomic Data relate to JSON?</a></h1>
<h2><a class="header" href="#from-atomic-data-to-json" id="from-atomic-data-to-json">From Atomic Data to JSON</a></h2>
<h2><a class="header" href="#from-json-to-atomic-data" id="from-json-to-atomic-data">From JSON to Atomic Data</a></h2>
<p>Atomic Data requires a bit more information about pieces of data than JSON tends to contain. Let's take a look at an example:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;John&quot;,
  &quot;birthDate&quot;: &quot;1991-01-20&quot;
}
</code></pre>
<p>The following things are missing:</p>
<ul>
<li>What is the URL of the resource being described?</li>
<li>What is the URL of the keys being used? (<code>name</code> and <code>birthDate</code>), and consequentially, how should the values be parsed?</li>
</ul>
<p>We can add this data by adding <em>context</em>:</p>
<pre><code class="language-json">{
  &quot;@context&quot;: {
    &quot;name&quot;: &quot;https://example.com/properties/name&quot;,
    &quot;birthDate&quot;: &quot;https://example.com/properties/birthDate&quot;,
    &quot;@id&quot;: &quot;https://example.com/people/john&quot;
  },
  &quot;name&quot;: &quot;John&quot;,
  &quot;birthDate&quot;: &quot;1991-01-20&quot;
}
</code></pre>
<p>The JSON above is called JSON-LD. It is still perfectly valid JSON, but it contains more information, and in turn can be converted into RDF formats.
TODO!</p>
<h2><a class="header" href="#json-ld-requirements" id="json-ld-requirements">JSON-LD Requirements</a></h2>
<ul>
<li>Make sure the URLs used in the <code>@context</code> resolve to Atomic Properties.</li>
</ul>
<h1><a class="header" href="#types-of-atomic-graphs" id="types-of-atomic-graphs">Types of Atomic Graphs</a></h1>
<p>An Graph is a set of Atoms.
Since Atomic Data is desgigned to facilitate decentralized data storage, Graphs will often lack information or contain invalid data.
In this section, we define some of these aspects of Graphs.</p>
<ul>
<li>A <strong>Valid Graph</strong> contains no mismatches between Datatypes from Properties and their usage in Atoms</li>
<li>A <strong>Closed Graph</strong> contains no unfetched outgoing links</li>
<li>A <strong>Verified Graph</strong> contains only Atoms from a verified Author</li>
<li>A <strong>Schema Complete Graph</strong> contains all used linked Properties</li>
</ul>
<p>These concepts are important when creating an implementation of a Store.</p>
<h2><a class="header" href="#valid-graphs" id="valid-graphs">Valid Graphs</a></h2>
<p>We refer to a Graph as Valid, if the following constraints are met:</p>
<ul>
<li><strong>The Datatypes are correctly used</strong>. The Graph does not contain Atoms where the Datatype of the Object does not match the Datatype of the Property of the Atom.</li>
<li><strong>The links work</strong>. All URLs used in the Graph (Subject, Predicate, Object) resolve correctly to the required Datatype.</li>
<li><strong>The Class Restrictions are met</strong>. If a Class sets required properties, these must be present in Resources that are instances of that Class.</li>
</ul>
<p>Making sure Graphs are Valid is of great imporance to anyone creating, sharing or using Atomic Data.
Services should specify whether they check the validity of graphs.</p>
<h2><a class="header" href="#closed-graph" id="closed-graph">Closed Graph</a></h2>
<p>A Graph is Closed, when the Resources of all URLs are present in the Graph.
In other words, if you were to fetch and download every single URL in a Graph, you would not have any more Atoms than before.
Closed Graphs are <em>rarely</em> required, it's often perfectly fine to have outgoing links that do not have been fetched.</p>
<h2><a class="header" href="#schema-complete-graphs" id="schema-complete-graphs">Schema Complete Graphs</a></h2>
<p>When a Graph has a set of Atoms, it might not posess all the information that is required to determine the datatype of each Atom.
When that is the case, we say the Graph is <em>Schema Complete</em>.</p>
<p>Having a Schema Complete Graph is essential for determining what the Datatype is of an Object.
Most implementations of Atomic Data will need Schema Completenss to create fitting views, or apply functinoal business logic.</p>
<p>Imagine some application (perhaps an app running inside a webbrowser) that has only the following data:</p>
<pre><code class="language-ndjson">[&quot;https://example.com/john&quot;,&quot;https://example.com/birthDate&quot;,&quot;1991-01-20&quot;]
</code></pre>
<p>Now, by looking at this single Atom, we might assume that the Object is an ISO date,
but this type information is not known yet to the application.
This type information should be specified in the <code>example:birthDate</code> Property.
It is the responsibility of the application to make sure it posesses the required Schema data.</p>
<p>We say a Graph is <em>Schema Complete</em> when it contains <em>at least</em> all the Properties that are used in predicates.</p>
<p>So let's add the missing Property: <code>https://example.com/birthDate</code></p>
<pre><code class="language-ndjson">[&quot;https://example.com/john&quot;,&quot;https://example.com/birthDate&quot;,&quot;1991-01-20&quot;]
[&quot;https://example.com/birthDate&quot;,&quot;https://atomicdata.dev/datatypes/Datatype&quot;,&quot;https://atomicdata.dev/datatypes/dateTime&quot;]
</code></pre>
<p>Now, since we've introduced yet another Property, we need to include that one as well:</p>
<pre><code class="language-ndjson">[&quot;https://example.com/john&quot;,&quot;https://example.com/birthDate&quot;,&quot;1991-01-20&quot;]
[&quot;https://example.com/birthDate&quot;,&quot;https://atomicdata.dev/datatypes/Datatype&quot;,&quot;https://atomicdata.dev/datatypes/dateTime&quot;]
[&quot;https://atomicdata.dev/datatypes/Datatype&quot;,&quot;https://atomicdata.dev/datatypes/Datatype&quot;,&quot;https://atomicdata.dev/datatypes/atomicURI&quot;]
</code></pre>
<p>Since all valid Atomic Data requires predicates to resolve to Atomic Properties, which are required to have an associated DataType...
We can safely say that the last atom in the example above (the one describing <code>https://atomicdata.dev/datatypes/Datatype</code>) will have to be present in all Schema Complete Atomic Graphs.</p>
<h1><a class="header" href="#tooling-for-atomic-data" id="tooling-for-atomic-data">Tooling for Atomic Data</a></h1>
<p>At this moment, no real tooling for Atomic Data exists.
Great tooling is required to make this a succes.
The following list is a set of ideas that we're likely to be working on.</p>
<h2><a class="header" href="#atomic-validator" id="atomic-validator">Atomic Validator</a></h2>
<p>Takes some Graph as an input, and validates its contents.
Could be useful for many purposes, and should be one of the first things to become available.
Not only should this parse Atomic-NDJSON, it should also make sure the URLs resolve and the DataTypes resolve.
Perhaps it should also return if non-standard Datatypes are being used, and if so, which ones.</p>
<h2><a class="header" href="#atomic-creator-cli" id="atomic-creator-cli">Atomic creator (CLI)</a></h2>
<p>A CLI tool for generating Atomic Data.
Should produce Atomic Mutations.</p>
<pre><code class="language-sh"># Create an atom
# atomic &lt;method&gt; &lt;subject&gt; &lt;predicate&gt; &lt;object&gt;
atomic add john birthdate 1991-01-20
# It's possible to use these keys instead of full URLs, as long as they are known locally,
# either in a local Atomic store a local prefixes file (e.g. ~/.ldget/prefixes)
# If the predicate is not used before, the CLI will ask for the required attributes (datatype, description) and create the Property
# The object will be parsed accordingly. If it does not meet the requirements, it wll not create the Atom.
# If everything is well, an Atomic Mutation will be sent to the Atomic Server
</code></pre>
<h2><a class="header" href="#atomic-server" id="atomic-server">Atomic server</a></h2>
<ul>
<li>Makes a graph available at some endpoint.</li>
<li>Responds to requests for created Atomic Resources (including Properties / DataTypes)</li>
<li>Offer useful query options (e.g. Triple Pattern Fragments)</li>
<li>Offers pub/sub functionality to clients that will want to listen to changes (Mutation Feed?)</li>
</ul>
<h2><a class="header" href="#atomizer-data-importer-and-conversion-kit" id="atomizer-data-importer-and-conversion-kit">Atomizer (data importer and conversion kit)</a></h2>
<ul>
<li>Import data from some data source (CSV / SQL / JSON / RDF), fill in the gaps (mapping / IRI creation / datatypes) an create new Atoms</li>
<li>Perhaps a CLI, library, GUI or a combination of all of these</li>
</ul>
<h2><a class="header" href="#libraries" id="libraries">Libraries</a></h2>
<p>The most important tooling for Atomic Data, are libraries.
Tools that developers use to fetch, manipulate and share Atomic Data inside their applications.
In this section, I'll create some rough API designs.</p>
<h3><a class="header" href="#atomic-js-javascript--typescript" id="atomic-js-javascript--typescript">Atomic-js (Javascript / Typescript)</a></h3>
<p>A JS compatible library, accessible as an NPM package is the most popular and developer friendly way to start.</p>
<p>Here's some pseudocode that indicates how it might be used:</p>
<pre><code class="language-js">import {createStore} from '@atomicdata';

const config = {
  // A URL to a TPF compatible endpoint where the data can be fetched
  tpfEndpoint: &quot;https://example.com/tpf&quot;,
  // A UTL to an Atomic Mutations endpoint where the client can subscribe to changes
  mutationsEndpoint: &quot;https://example.com/mutations&quot;,
  // A UTL to an Atomic Suggestions endpoint where the client can send suggested state changes
  sugestionsEndpoint: &quot;https://example.com/suggestions&quot;,
};

const store = createStore(config); // Initializes the store

// The `classInitializer` function takes an Atomic Class URI as its argument
// fetches the Class, its Properties and the DataTypes
// and returns a function that let's you create instances of that class
const personBuilder = await store.classInitializer(&quot;https://example.com/classes/Person&quot;);

// Create an instance of the Person Class
// An Atomic Suggestion is sent to the
const alice = await personBuilder({
  // The Subject field is optional, but recommended if you want to control its URL.
  // Otherwise, the Server will pick something
  subject: &quot;https://example.com/alice&quot;,
  // The IDE is aware of the existing keys and their acceptable values,
  // because a conversion from Atomic Classes and Properties
  // to typescript interfaces can be made automatically
  firstName: &quot;Alice&quot;,
  lastName: &quot;Anderson&quot;,
  bestFriend: &quot;https://example.com/Bob&quot;,
  birthDate: new Date(&quot;1991-01-20&quot;),
  // Since the URL in the key below can be fetched, and has a Property + Datatype, the IDE + the compiler can determine that 'true' is an acceptable type.
  &quot;https://example.com/someOtherProperty&quot;: true,
})

console.log(person.subject) //=&gt; Should return a newly created identifier

// Checks the store for the subject, and returns it.
// If it does not exists locally, it will fetch it first using the `tpfEndpoint`.
const alice = await store.get(&quot;https://example.com/alice&quot;)

// Because of the keys in Atomic Properties, we can use this dot syntax to traverse the graph and get a value
console.log(alice.bestFriend.firstName); // =&gt; &quot;Bob&quot;
</code></pre>
<p>I think a Developer Experience similar to the one above is essential for getting people to create linked data.
It should be incredibly easy, and this is what enables that.
However, realizing a library + IDE support as shown above is hard at the least, perhaps even impossible.
Theoretically, the information is accessible - but I'm not sure whether the IDE and the JS context (e.g. the Typescript compiler) can successfully see which shape is being returned by the <code>classInitializer</code> function.</p>
<h3><a class="header" href="#atomic-rs" id="atomic-rs">Atomic-rs</a></h3>
<p>Rust's compiler has strict type checking.
It also features a very flexible macro language, which could enable intuitive API designs for Atomic Data.
It could fetch the Properties and Classes at compile time, and convert these to</p>
<pre><pre class="playpen"><code class="language-rust">use atomic::{init_store}

fn main() {
  let mut graph = init_store();
  // TODO! Design a macro solution

}
</code></pre></pre>
<h2><a class="header" href="#atomic-browsser" id="atomic-browsser">Atomic Browsser</a></h2>
<p>A web-browser application that enables viewing, browsing, navigating Atomic Data.</p>
<h1><a class="header" href="#get-involved" id="get-involved">Get involved</a></h1>
<p>Atomic Data is an open specification, and that means that you're very welcome to share your thougts and help make this standard as good as possible.</p>
<p>Things you can do:</p>
<ul>
<li>Clone the <a href="https://github.com/ontola/atomic-data/">Book Repo</a> and read some of the inline comments, which might help start some discussions</li>
<li>Drop an <a href="https://github.com/ontola/atomic-data/issues">issue on Github</a> to share your suggestions or critisism</li>
<li>Join the <a href="https://discord.gg/ZspQv8">Discord server</a> for voice / text chat</li>
<li>Support our suggested <a href="https://www.w3.org/community/blog/2020/06/22/proposed-group-atomic-data-community-group/">W3C Community Group</a></li>
</ul>
<h2><a class="header" href="#authors" id="authors">Authors:</a></h2>
<ul>
<li>Joep Meindertsma (<a href="https://github.com/joepio/">joepio</a> from <a href="https://ontola.io/">Ontola.io</a>)</li>
</ul>
<h2><a class="header" href="#special-thanks-to" id="special-thanks-to">Special thanks to:</a></h2>
<ul>
<li>Thom van Kalkeren (who came up with many great ideas on how to work with RDF)</li>
<li>Tim Berners-Lee (for everything he did for linked data and the web)</li>
<li>Ruben Verborgh (for doing great work with RDF)</li>
<li>All the other people who worked on the RDF specification</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-121994595-2', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
