<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Atomic Data</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Documentation for the Atomic Data standard.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="atomic-data-overview.html"><strong aria-hidden="true">1.</strong> Atomic Data Overview</a></li><li class="chapter-item expanded "><a href="core/intro.html"><strong aria-hidden="true">2.</strong> Atomic Data Core</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="core/concepts.html"><strong aria-hidden="true">2.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="core/serialization.html"><strong aria-hidden="true">2.2.</strong> Serialization</a></li><li class="chapter-item expanded "><a href="core/querying.html"><strong aria-hidden="true">2.3.</strong> Querying</a></li><li class="chapter-item expanded "><a href="core/paths.html"><strong aria-hidden="true">2.4.</strong> Paths</a></li></ol></li><li class="chapter-item expanded "><a href="schema/intro.html"><strong aria-hidden="true">3.</strong> Atomic Schema</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="schema/classes.html"><strong aria-hidden="true">3.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="schema/datatypes.html"><strong aria-hidden="true">3.2.</strong> Datatypes</a></li><li class="chapter-item expanded "><a href="schema/translations.html"><strong aria-hidden="true">3.3.</strong> Translations</a></li><li class="chapter-item expanded "><a href="schema/faq.html"><strong aria-hidden="true">3.4.</strong> FAQ</a></li></ol></li><li class="chapter-item expanded "><a href="mutations/intro.html"><strong aria-hidden="true">4.</strong> Atomic Mutations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="mutations/concepts.html"><strong aria-hidden="true">4.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="mutations/suggestions.html"><strong aria-hidden="true">4.2.</strong> Suggestions</a></li><li class="chapter-item expanded "><a href="mutations/versioning.html"><strong aria-hidden="true">4.3.</strong> Versioning</a></li></ol></li><li class="chapter-item expanded "><a href="interoperability/intro.html"><strong aria-hidden="true">5.</strong> Interoperability</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="interoperability/rdf.html"><strong aria-hidden="true">5.1.</strong> Relation to RDF</a></li><li class="chapter-item expanded "><a href="interoperability/json.html"><strong aria-hidden="true">5.2.</strong> Relation to JSON</a></li><li class="chapter-item expanded "><a href="interoperability/ipfs.html"><strong aria-hidden="true">5.3.</strong> Relation to IPFS</a></li></ol></li><li class="chapter-item expanded "><a href="core/validations.html"><strong aria-hidden="true">6.</strong> Types of Graph Validations</a></li><li class="chapter-item expanded "><a href="tooling.html"><strong aria-hidden="true">7.</strong> Tooling</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="get-involved.html">Get involved</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Atomic Data</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/ontola/atomic-data" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#atomic-data-overview" id="atomic-data-overview">Atomic Data Overview</a></h1>
<p><em>Status: early draft, far from usable. <a href="get-involved.html">Feedback welcome</a>.</em></p>
<p>Atomic Data is a proposed standard for modeling and exchanging data.
It uses links to connect pieces of data, and therefore makes it easier to connect datasets to each other - even when these datasets exist on separate machines.</p>
<p>Atomic Data is especially suitable for knowledge graphs, distributed datasets, semantic data, p2p applications, decentralized apps, and data that is meant to be highly reusable.
It is designed to be highly extensible, easy to use, and to make the process of domain specific standardization as simple as possible.</p>
<p>Atomic Data is <a href="https://ontola.io/what-is-linked-data/">Linked Data</a>, as it is a more strict subset of RDF.
It is typed (you know if something is a <code>string</code>, <code>number</code>, <code>URL</code>, etc.) and extensible through <a href="schema/intro.html">Atomic Schema</a>, which means that you can define your own Classes, Properties and Datatypes.
Atomic Data has a standard for synchronizing data by communicating state changes, called <a href="mutations/intro.html">Atomic Mutations</a>.
You can use parts of Atomic Data separately, but the standard is designed as a full, integrated data management package that makes it easier to create, share and use structured data on the web.</p>
<ul>
<li><a href="core/intro.html">Atomic Data Core</a>: the core model for typed, Linked Data</li>
<li><a href="schema/intro.html">Atomic Schema</a>: defining properties, datatypes and classes</li>
<li><a href="mutations/intro.html">Atomic Mutations</a>: sharing state changes, verifying changes and collaboration</li>
</ul>
<h2><a class="header" href="#motivation" id="motivation">Motivation</a></h2>
<p>Linked data (RDF / the semantic web) enables us to use the web as a large, decentralized graph database.
Using links everywhere in data has amazing merits: links remove ambiguity, they enable exploration, they enable connected datasets.
Linked Data could help to democratize the web by decentralizing information storage, and giving people more control.
The Solid Project by Tim Berners-Lee is a great example of why linked data can help to create a more decentralized web.</p>
<p>At <a href="ontola.io/">Ontola</a>, we've been working with linked data quite intensely for the last couple of years.
We went all-in on RDF, and challenged ourselves to create software that communicates exclusively using it.
That has been an inspiring, but also sometimes a frustrating journey.
While building various production grade apps (e.g. our e-democracy platform <a href="https://argu.co/">Argu.co</a>, which is used by various governments), we had to solve many problems.
How to properly model data in RDF? How to deal with sequences? How do you deal with mutations? Converting to HTML? Typing? CORS?
We tackled some of these problems by having a tight grip on the data that we create (e.g. we know the type of data, because we control the resources), and another part is creating new protocols, formats, tools, and libraries.
But it took a long time, and it was hard.
It's been almost 15 years since the <a href="https://www.w3.org/DesignIssues/LinkedData.html">introduction of linked data</a>, and its adoption has been slow.
We know that some of its merits are undeniable, and we truly want the semantic web to succeed.
We believe the lack of growth partially has to do with a lack of tooling, but also with <a href="../interoperability/rdf.html#why-these-changes">some problems that lie in the RDF data model</a>.</p>
<p>Atomic Data aims to take the best parts from RDF, and learn from the past to make a more developer-friendly, performant and reliable data model to achieve a truly linked web.</p>
<h1><a class="header" href="#atomic-data-core" id="atomic-data-core">Atomic Data Core</a></h1>
<p>The Atomic Data Core describes the fundamental data model of Atomic Data.
Before we dive into its concepts, we'll talk about why this standard is made in the first place.</p>
<h2><a class="header" href="#design-goals" id="design-goals">Design goals</a></h2>
<ul>
<li><strong>Browsable</strong>: Data should explicitly link to other pieces of data, and these links should be followable.</li>
<li><strong>Semantic</strong>: Every data Atom and relation has a clear semantic meaning.</li>
<li><strong>Open</strong>: Free to use, open source, no strings attached.</li>
<li><strong>Clear Ownership</strong>: The data shows who is in control of the data, so new versions of the data can easily be retrieved.</li>
<li><strong>Mergeable</strong>: Any two sets of Atoms can be merged into a single graph without any merge conflicts / name collisions.</li>
<li><strong>Interoperable</strong>: Can easily and constantly be converted to other data formats (e.g. JSON, XML, and all RDF formats).</li>
<li><strong>Extensible</strong>: Anyone can define their own data types and create Atoms with it.</li>
<li><strong>ORM-friendly</strong>: Navigate a <em>decentralized</em> graph by using dot.syntax, similar to how you navigate a JSON object in javascript.</li>
<li><strong>Typed</strong>: All valid Atomic data has an unambiguous, static datatype. Models expressed in Atomic Data can be mapped to programming language models, such as <code>structs</code> or <code>interfaces</code> in Typescript / Rust / Go.</li>
</ul>
<p>Note that for these last four goals, <a href="core/../schema/intro.html">Atomic Schema</a> is required.</p>
<h1><a class="header" href="#atomic-data-core-concepts" id="atomic-data-core-concepts">Atomic Data Core: Concepts</a></h1>
<p>Understanding the Core concepts of Atomic Data are fundamental for reading the rest of the documentation.</p>
<h2><a class="header" href="#atomic-data" id="atomic-data">Atomic Data</a></h2>
<p>Atomic Data is a data format for representing information on the web.
It is a directed, labeled graph, similar to RDF.
It can be used to express any type of information, including personal data, vocabularies, metadata, documents, files and more.
Contrary to some other (labeled) graph data models, a relationship between two items (Resources) does not have attributes.</p>
<h2><a class="header" href="#atom-or-atomic-triple" id="atom-or-atomic-triple">Atom (or Atomic Triple)</a></h2>
<p>The smallest possible piece of <em>meaningful</em> data / information.
The model of an Atom is comparable with an RDF Triple / Statement (<a href="core/../interoperability/rdf.html">although there are important differences</a>).
An Atom consists of three fields:</p>
<ul>
<li><strong><a href="core/concepts.html#subject-field">Subject</a></strong>: the Thing that the atom is providing information about.</li>
<li><strong><a href="core/concepts.html#property-field">Property</a></strong>: the property of the Thing that the atom is about (will always be a URL to a <a href="core/../schema/classes.html#property">Property</a>).</li>
<li><strong><a href="core/concepts.html#value-field">Value</a></strong>: the new piece of information about the Atom.</li>
</ul>
<p>Let's turn this sentence into Atoms:</p>
<p><code>Arnold, who's born on the 20th of Januari 1991, has a best friend named Britta.</code></p>
<pre><code class="language-ad3">[&quot;https://example.com/arnold&quot;,&quot;https://example.com/properties/bornAt&quot;,&quot;1991-01-20&quot;]
[&quot;https://example.com/arnold&quot;,&quot;https://example.com/properties/firstName&quot;,&quot;Arnold&quot;]
[&quot;https://example.com/arnold&quot;,&quot;https://example.com/properties/bestFriend&quot;,&quot;https://example.com/britta&quot;]
[&quot;https://example.com/britta&quot;,&quot;https://example.com/properties/firstName&quot;,&quot;Britta&quot;]
</code></pre>
<p>In the Atomic Data above, we have:</p>
<ul>
<li>four different Atoms (every line is an Atom)</li>
<li>two different Subjects: <code>https://example.com/arnold</code> and <code>https://example.com/britta</code>.</li>
<li>three different Properties (<code>https://example.com/properties/bornAt</code>, <code>https://example.com/properties/firstName</code>, and <code>https://example.com/properties/bestFriend</code>)</li>
<li>four different Values (<code>1991-0-20</code>, <code>Arnold</code>, <code>https://example.com/britta</code> and <code>Britta</code>)</li>
</ul>
<p>All Subjects and Properties are URLs, they are links that can be retrieved.
One of the Values is a URL, too, but what are the others?
Their Datatypes are defined by the Properties.
For example, the <code>https://example.com/properties/bornAt</code> Property requires an ISO Date string, and the <code>https://example.com/properties/firstName</code> Property requires a regular string.</p>
<h2><a class="header" href="#subject-field" id="subject-field">Subject field</a></h2>
<p>The Subject field is the first part of an Atom.
It is the identifier that the rest of the Atom is providing information about.
It's a URL that points to the Resource.
The creator of the Subject MUST make sure that it resolves.
In other words: following / downloading the Subject link will provide you with all the Atoms about the Subject (see <a href="core/querying.html">Atomic Querying</a>.</p>
<h2><a class="header" href="#property-field" id="property-field">Property field</a></h2>
<p>The Property field is the second part of an Atom.
In RDF, this is called a <code>predicate</code>.
It is a URL that points to an Atomic <a href="core/../schema/classes.html#Property">Property</a>.
For example <code>https://example.com/createdAt</code> or <code>https://example.com/firstName</code>.</p>
<!-- Making this a requirement is what makes Atomic Data typed and semantic -->
<p>The Property field MUST be a URL, and that URL MUST resolve to an Atomic Property, which contains information about the Datatype.</p>
<h2><a class="header" href="#value-field" id="value-field">Value field</a></h2>
<p>The Value field is the third part of an Atom.
In RDF, this is called an <code>object</code>.
Contrary to the Subject and Property values, the Value can be of any datatype.
This includes URLs, strings, integers, dates and more.</p>
<h2><a class="header" href="#graph" id="graph">Graph</a></h2>
<p>A Graph is a set of Atoms.
A Graph can describe various subjects, and may or may not be related.
Graphs can have several characteristics (Schema Complete, Valid, Closed)</p>
<h2><a class="header" href="#resource" id="resource">Resource</a></h2>
<p>A Resource is a set of Atoms (a Graph) that share the same Subject URL.
Every thing is Resource, such as the person &quot;Michael Jackson&quot;, or the abstract class &quot;Person&quot;.
All the concepts on this page are Resources.
A</p>
<p>Properties:</p>
<ul>
<li><code>a</code> - (optional, AtomicURL) the <a href="core/../schema/classes.html#class">Class</a> of the Resource.</li>
</ul>
<h2><a class="header" href="#atomic-web" id="atomic-web">Atomic Web</a></h2>
<p>The Atomic Web refers to all Atomic Graphs on the web.</p>
<h1><a class="header" href="#serialization-of-atomic-data" id="serialization-of-atomic-data">Serialization of Atomic Data</a></h1>
<p>Atomic Data is not necessarily bound to a single serialization format.
It's fundamentally a data model, and that's an important distinction to make.
However, it's recommended to use <code>ad3</code>, which is specifically designed to be a simple and performant format for Atomic Data.</p>
<h2><a class="header" href="#atomictriples-ad3" id="atomictriples-ad3">AtomicTriples (.ad3)</a></h2>
<p>A single Atom can be represented by an array of three strings, respectively representing the Subject, Property and Value.</p>
<p>It looks like this:</p>
<pre><code class="language-ad3">[&quot;https://example.com/subject&quot;,&quot;https://example.com/property&quot;,&quot;some object&quot;]
[&quot;https://example.com/subject&quot;,&quot;https://example.com/otherProperty&quot;,&quot;https://example.com/somethingelse&quot;]
</code></pre>
<p>It uses Newline Delimited JSON (<a href="http://ndjson.org/">NDJSON</a>) for serialization, which is just a large string with newlines between each JSON object.</p>
<p>NDJSON has some important benefits:</p>
<ul>
<li><strong>Streaming parsing</strong>: An NDJSON document can be parsed before it's fully loaded / transmitted. That is not possible with regular JSON.</li>
<li><strong>High compatibility</strong>: NDJSON parsers can use JSON parsers, and are therefore everywhere.</li>
<li><strong>Performance</strong>: Modern browsers have highly performant JSON parsing, which means that it's <em>fast</em> in one of the most important contexts: the browser.</li>
</ul>
<p><em>Mime type (not registered yet!): <code>application/ad3-ndjson</code></em></p>
<p><em>File name extension: <code>.ad3</code></em></p>
<p>Disclaimer: note that Atomic-NDJSON is useful for communicating <em>current state</em>, but not for <em>state changes</em>.</p>
<p>Atomic Triples is heavily inspired by <a href="https://github.com/ontola/hextuples">NDJSON HexTuples</a>.</p>
<p>Example serialization implementation written in Rust, to show you how <em>easy</em> it is to serialize this!</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn serialize_atoms_to_ad3(atoms: Vec&lt;Atom&gt;) -&gt; AtomicResult&lt;String&gt; {
    let mut string = String::new();
    for atom in atoms {
        // Use an exsting JSON serialization library to take care of the hard work (escaping quotes, etc.)
        let mut ad3_atom = serde_json::to_string(&amp;vec![&amp;atom.subject, &amp;atom.property, &amp;atom.value])?;
        ad3_atom.push_str(&quot;\n&quot;);
        &amp;string.push_str(&amp;*ad3_atom);
    }
    return Ok(string);
}
<span class="boring">}
</span></code></pre></pre>
<p>And an example parser:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn parse_ad3&lt;'a, 'b&gt;(string: &amp;'b String) -&gt; AtomicResult&lt;Vec&lt;Atom&gt;&gt; {
    let mut atoms: Vec&lt;Atom&gt; = Vec::new();
    for line in string.lines() {
        match line.chars().next() {
            // These are comments
            Some('#') =&gt; {}
            Some(' ') =&gt; {}
            // That's an array, let's do this!
            Some('[') =&gt; {
                let string_vec: Vec&lt;String&gt; =
                    parse_json_array(line).expect(&amp;*format!(&quot;Parsing error in {:?}&quot;, line));
                if string_vec.len() != 3 {
                    return Err(format!(
                        &quot;Wrong length of array at line {:?}: wrong length of array, should be 3&quot;,
                        line
                    )
                    .into());
                }
                let subject = &amp;string_vec[0];
                let property = &amp;string_vec[1];
                let value = &amp;string_vec[2];
                atoms.push(Atom::new(subject, property, value));
            }
            Some(char) =&gt; {
                return Err(format!(
                    &quot;AD3 Parsing error at {:?}, cannot start with {}&quot;,
                    line, char
                )
                .into())
            }
            None =&gt; {}
        };
    }
    return Ok(atoms);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#atomicdoubles-ad2" id="atomicdoubles-ad2">AtomicDoubles (.ad2)</a></h2>
<p>AtomicDoubles is similar to AtomicTriples, with one exception: the Subject is left out.
For many use-cases, omitting the Subject is a <em>bad idea</em>.
It means that you can't describe multiple resources in a single document, and that is useful in many contexts.</p>
<p>However, omitting the subject can be useful in (at least) three scenarios:</p>
<ul>
<li>The <strong>Subject is not yet known when creating the data</strong> (for example, because it still has to be determined by some server or hash function).</li>
<li>The <strong>Subject is already known by the client</strong>, and leaving it out saves bandwidth. This happens for example during Subject Fetching, where the request itself contains the Subject, because the fetched URL itself is the Subject of all returned triples. Note that in this scenario, the server is unable to include</li>
<li>The <strong>Atoms are only valid coming from a specific source</strong>. Since</li>
</ul>
<pre><code class="language-ndjson">[&quot;https://example.com/property&quot;,&quot;some object&quot;]
[&quot;https://example.com/otherProperty&quot;,&quot;https://example.com/somethingelse&quot;]
</code></pre>
<p>Keep in mind that this approach also has some downsides:</p>
<ul>
<li>
<p>It becomes impossible to include other resources in a single serialized document / response.</p>
</li>
<li>
<p><em>Mime type (not registered yet!): <code>application/ad2-ndjson</code></em></p>
</li>
<li>
<p><em>File name extension: <code>.ad2</code></em></p>
</li>
</ul>
<h2><a class="header" href="#rdf-serialization-formats" id="rdf-serialization-formats">RDF serialization formats</a></h2>
<p>Because of the similarities with RDF, RDF serialization formats can be used to communicate and store Atomic Data, such as N-Triples, Turtle, HexTuples or JSON-LD.
<em>However</em>, keep in mind that RDF users will expect other things from their data.
Read more about the various existing formats and their respective merits <a href="https://ontola.io/blog/rdf-serialization-formats/">here</a>.
Read more about serializing Atomic Data to RDF in the <a href="core/../interoperability/rdf.html">RDF interoperability section</a>.</p>
<h2><a class="header" href="#future-serialization-formats" id="future-serialization-formats">Future serialization formats</a></h2>
<p>In the future, new serialization formats will be introduced.
Here's some (vague) ideas that might inspire you to design one:</p>
<h3><a class="header" href="#atomicdata-fs" id="atomicdata-fs">AtomicData-FS</a></h3>
<p>Possible extension: <code>.adf</code></p>
<p>FS stands for FileSystem.
It should be designed as a format that's easy to manipulate Atomic Data by hand, using plaintext editors and IDE software.
It fits nicely in our line-based paradigm, where we us IDEs and Github to manage our information.
It should use Shortnames wherever possible to make life easier for those who modify instances.
It might use hierarchical path structures to shape URLs.
It might use hierarchical path structures to shape data, and set constraints (e.g. all items directly in the <code>./person</code> directory should be Person instances).
Folder structure should reflect the structure inside URLs.</p>
<p>Note that this format is <em>not</em> useful for sending arbitrary Atomic Data to some client.
It is useful for managing Atomic Data from a filesystem.</p>
<p>An example AtomicData-FS dir can be <a href="https://github.com/ontola/atomic-data/tree/master/examples/atomic-fs/people">found in the repo</a>.</p>
<pre><code># in ./projectDir/people/john.adf
# serialization uses YAML syntax
firstName: John
lastName: McLovin
# If a Property is not available in the Class, you can the URL of the property
https://schema.org/birthDate: 1991-01-20
# Perhaps support relative paths to other local resources
bestFriend: ./mary
</code></pre>
<p>Perhaps YAML isn't the right pick for this, because it's kind of hard to parse.</p>
<h3><a class="header" href="#atomicdata-binary" id="atomicdata-binary">AtomicData-Binary</a></h3>
<p>Possible extension: <code>.adb</code></p>
<p>A binary serialization format, designed to be performant and highly compressed.
Perhaps it works like this:</p>
<ul>
<li>An <code>adb</code> file consists of a large sequence of Maps and Statements</li>
<li>A <em>Map</em> is a combination of an internal identifiers (the <em>ID</em>, some short binary object) and a URL strings. These make sure that URLs can be used again cheaply, if they are used multiple times.</li>
<li>A <em>Statement</em> is a set of two IDs and a value, which can be a String, a URL or some binary format.</li>
<li>Perhaps some extra compression is possible, because many URLs will have a common domain.</li>
</ul>
<h1><a class="header" href="#querying-atomic-data" id="querying-atomic-data">Querying Atomic Data</a></h1>
<p>There are multiple ways of getting Atomic Data into some system:</p>
<ul>
<li><a href="core/paths.html"><strong>Atomic Paths</strong></a> is a simple way to traverse Atomic Graphs and target specific values</li>
<li><a href="core/querying.html#subject-fetching-http"><strong>Subject Fetching</strong></a> requests a single subject right from its source</li>
<li><a href="core/querying.html#triple-pattern-fragments"><strong>Triple Pattern Fragments</strong></a> allows querying for specific (combinations of) Subject, Property and Value.</li>
<li><a href="core/querying.html#SPARQL"><strong>SRARQL</strong></a> is a powerful Query language for traversing graphs</li>
</ul>
<h2><a class="header" href="#atomic-paths" id="atomic-paths">Atomic Paths</a></h2>
<p>An Atomic Path is a string that consist of one or more URLs, which when traversed point to an item.
For more information, see <a href="core/paths.html">Atomic Paths</a>.</p>
<h2><a class="header" href="#subject-fetching-http" id="subject-fetching-http">Subject fetching (HTTP)</a></h2>
<p>The simplest way of getting Atomic Data when the Subject is an HTTP URL, is by sending a GET request to the subject URL.
Set the <code>Content-Type</code> header to an Atomic Data compatible mime type, such as <code>application/ad3-ndjson</code>.</p>
<pre><code class="language-HTTP">GET https://example.com/myResource HTTP/1.1
Content-Type: application/ad3-ndjson
</code></pre>
<p>The server SHOULD respond with all the Atoms of which the requested URL is the subject:</p>
<pre><code class="language-HTTP">HTTP/1.1 200 OK
Content-Type: application/ad3-ndjson
Connection: Closed

[&quot;https://example.com/myResource&quot;,&quot;https://example.com/properties/name&quot;,&quot;My awesome resource!&quot;]
</code></pre>
<p>The server MAY also include other resources, if they are deemed relevant.</p>
<h2><a class="header" href="#subject-fetching-ipfs" id="subject-fetching-ipfs">Subject Fetching (IPFS)</a></h2>
<p>IPFS is a new protocol for sharing data using content-addressing.</p>
<h2><a class="header" href="#triple-pattern-fragments" id="triple-pattern-fragments">Triple Pattern Fragments</a></h2>
<p><a href="https://linkeddatafragments.org/specification/triple-pattern-fragments/">Triple Pattern Fragments</a> (TPF) is an interface for querying RDF.
It works great for Atomic Data as well.</p>
<p>An HTTP implementation of a TPF endpoint might accept a GET request to a URL such as this:</p>
<p><code>http://example.org/tpf?subject={subject}&amp;property={property}&amp;value={value}</code></p>
<p>Make sure to URL encode the <code>subject</code>, <code>property</code>, <code>value</code> strings.</p>
<p>For example, let's search for all Atoms where the value is <code>test</code>.</p>
<pre><code class="language-HTTP">GET https://example.com/tpf?value=&quot;test&quot; HTTP/1.1
Content-Type: application/ad3-ndjson
</code></pre>
<p>This is the HTTP response:</p>
<pre><code class="language-HTTP">HTTP/1.1 200 OK
Content-Type: application/ad3-ndjson
Connection: Closed

[&quot;https://example.com/myResource&quot;,&quot;https://example.com/properties/name&quot;,&quot;test&quot;]
</code></pre>
<!--
## Bulk API

Bulk-API is an (currently still closed) in-development specification for asking for multiple Subjects in one request.
This is especially useful in browser clients that traverse the graph iteratively, and HTTP/2 is not an option. -->
<h2><a class="header" href="#sparql" id="sparql">SPARQL</a></h2>
<p><a href="https://www.w3.org/TR/rdf-sparql-query/">SPARQL</a> is a powerful RDF query language.
Since all Atomic Data is also valid RDF, it should be possible to query Atomic Data using SPARQL.</p>
<h1><a class="header" href="#atomic-paths-1" id="atomic-paths-1">Atomic Paths</a></h1>
<p>An Atomic Path is a string that consists of at least one URL, followed by one or more URLs or Shortnames.
Every single value in an Atomic Resource can be targeted through such a Path.
They can be used as identifiers for specific Values.</p>
<p>The simplest path, is the URL of a resource, which represents the entire Resource with all its properties.
If you want to target a specific atom, you can use an Atomic Path with a second URL.
This second URL can be replaced by a Shortname, if the Resource is an instance of a class which has properties with that shortname (sounds more complicated than it is).</p>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<p>Let's start with this simple graph:</p>
<pre><code class="language-json">[&quot;https://example.com/john&quot;, &quot;https://example.com/lastName&quot;, &quot;McLovin&quot;]
</code></pre>
<p>Then the following Path targets the <code>McLovin</code> value:</p>
<p><code>https://example.com/john https://example.com/lastname</code> =&gt; <code>McLovin</code></p>
<p>If the resource is an instance of a Class (an <code>atomic:isA</code> property), you can use the Shortnames of the Properties that are referred to by that class.
Since John is an instance of a Person, he might have a <code>lastname</code> which maps to <code>https://example.com/latname</code>.</p>
<p><code>https://example.com/john lastname</code> =&gt; <code>McLovin</code></p>
<p>We can also traverse relationships:</p>
<pre><code class="language-ad3">[&quot;https://example.com/john&quot;, &quot;https://atomicdata.dev/properties/isA&quot;, &quot;https://example.com/Person&quot;]
[&quot;https://example.com/john&quot;, &quot;https://example.com/lastName&quot;, &quot;McLovin&quot;]
[&quot;https://example.com/john&quot;, &quot;https://example.com/employer&quot;, &quot;https://example.com/XCorp&quot;]
[&quot;https://example.com/XCorp&quot;, &quot;https://example.com/description&quot;, &quot;The greatest company!&quot;]
</code></pre>
<p><code>https://example.com/john employer description</code> =&gt; <code>The greatest company!</code></p>
<p>In the example above, the XCorp subject exists and is the source of the <code>The greatest company!</code> value.
However, using paths, it's also possible to created nested resources <em>without creating new URLs for all children</em>.
If you've worked with RDF, this is what Blank Nodes are used for.</p>
<p>Let's make the path above resolve without having an explicit URL for XCorp:</p>
<pre><code class="language-ad3">[&quot;https://example.com/john&quot;, &quot;https://example.com/lastName&quot;, &quot;McLovin&quot;]
[&quot;https://example.com/john https://example.com/employer&quot;, &quot;https://example.com/description&quot;, &quot;The greatest company!&quot;]
</code></pre>
<p>Serialization formats are free to use nesting to denote paths - which means that it is not necessary to include these path strings explicitly in most serialization formats.</p>
<p>For example:</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://example.com/john&quot;,
  &quot;@context&quot;: &quot;https://example.com/person&quot;,
  &quot;hasShoes&quot;: [
    {
      &quot;name&quot;: &quot;Mr. Boot&quot;,
    },
    {
      &quot;name&quot;: &quot;Sunny Sandals&quot;,
    }
  ]
}
</code></pre>
<p>The Path of <code>Mr. Boot</code> is:</p>
<pre><code>https://example.com/john hasShoes 1 name
</code></pre>
<p>This Path is useful for storing the value in other serialization formats, such as <code>.ad3</code>:</p>
<pre><code class="language-ad3">[&quot;https://example.com/john https://example.com/hasShoes 0&quot;, &quot;https://example.com/name&quot;, &quot;Mr. Boot&quot;]
[&quot;https://example.com/john https://example.com/hasShoes 1&quot;, &quot;https://example.com/name&quot;, &quot;Sunny Sandals&quot;]
</code></pre>
<p>You can target an item in an array by using a number to indicate its position, starting with 0.</p>
<p>Notice how the Resource with the <code>name: Mr. Boot</code> does not have an explicit <code>@id</code>, but it <em>does</em> have a Path.</p>
<h1><a class="header" href="#atomic-schema" id="atomic-schema">Atomic Schema</a></h1>
<p>Atomic Schema is the proposed standard for specifying classes, properties and datatypes in Atomic Data.
You can compare it to what XSD is for XML.
Atomic Schema deals with the</p>
<p>This section will define various Classes, Properties and Datatypes (discussed in <a href="schema/../core/concepts.html">Atomic Core: Concepts</a>).</p>
<h2><a class="header" href="#design-goals-1" id="design-goals-1">Design Goals</a></h2>
<ul>
<li><strong>Typed</strong>: Every Atom of data has a clear datatype.</li>
<li><strong>IDE-friendly</strong>: You should not have to type full URLs - the schema sets shortnames.</li>
<li><strong>Self-documenting</strong>: When seeing a piece of data, simply following links will explain you how the model is to be understood. This removes the need for (most of) existing API documentation.</li>
<li><strong>Performant</strong>: Datatypes can have a binary representation for optimal storage, communication, serialization and parsing efficiency.</li>
<li><strong>Extensible</strong>: Anybody can create their own Datatypes, Properties and Classes.</li>
<li><strong>Accessible</strong>: Support for languages, easily translatable. Useful for humans and machines.</li>
<li><strong>Atomic</strong>: All the design goals of Atomic Data itself also apply here.</li>
<li><strong>Self-describing</strong>: Atomic Schema is to be described as Atomic Data using Atomic Schema.</li>
</ul>
<h2><a class="header" href="#in-short" id="in-short">In short</a></h2>
<p>In short, Atomic Schema works like this:</p>
<p>The Property <em>field</em> in an Atom links to a <strong>Property <em>Resource</em></strong>. It is important that the URL to the Property Resource resolves.
This Property does three things:</p>
<ol>
<li>it tells something about its semantic meaning, and links to a Datatype.</li>
<li>it links to a Datatype or Class, which indicates which Value is acceptable.</li>
<li>it provides a Shortname, which is used for ORM.</li>
</ol>
<p><strong>DataTypes</strong> define the shape of the Value, e.g. a Number (<code>124</code>) or Boolean (<code>true</code>).</p>
<p><strong>Classes</strong> are a special kind of Resource that describe an abstract class of things (such as &quot;Person&quot; or &quot;Blog&quot;).
Classes can <em>recommend</em> or <em>require</em> a set of Properties.
They behave as Models, similar to <code>struts</code> in C or <code>interfaces</code> in Typescript.
A Resource <em>could</em> have one or more classes, which <em>could</em> provide information about which Properties are expected or required.</p>
<h1><a class="header" href="#atomic-schema-classes" id="atomic-schema-classes">Atomic Schema: Classes</a></h1>
<h2><a class="header" href="#how-to-read-classes" id="how-to-read-classes">How to read classes</a></h2>
<p>Example:</p>
<ul>
<li><code>description</code> - (required, AtomicURL, TranslationBox) human readable explanation of what the Class represents.</li>
</ul>
<p>Means:</p>
<p>This class has a <em>required</em> property with shortname <code>description</code>.
This Property has a Datatype of <code>AtomicURL</code>, and these should point to <code>TranslationBox</code> instances.</p>
<p><em>Note: the URLs for properties are missing and will be added at a later time.</em></p>
<h2><a class="header" href="#property" id="property">Property</a></h2>
<p><em>URL: <code>https://atomicdata.dev/classes/Property</code></em></p>
<p>The Property class.
The thing that the Property field should link to.
A Property is an abstract type of Resource that describes the relation between a Subject and a Value.
A Property provides some semantic information about the relationship (in its <code>description</code>), it provides a shorthand (the <code>shortname</code>) and it links to a Datatype.
Here's a <a href="schema/properties.html">list of useful Properties</a>.
You can constrain properties further by using <a href="https://www.w3.org/TR/shacl/#property-shapes">SHACL Properties</a>.</p>
<p>Properties of a Property instance:</p>
<ul>
<li><code>shortname</code> - (required, Slug) the shortname for the property, used in ORM-style dot syntax (<code>thing.property.anotherproperty</code>).</li>
<li><code>description</code> - (optional, AtomicURL, TranslationBox) the semantic meaning of the.</li>
<li><code>datatype</code> - (required, AtomicURL, Datatype) a URL to an Atomic Datatype, which defines what the datatype should be of the Value in an Atom where the Property is the</li>
<li><code>classtype</code> - (optional, AtomicURL, Class) if the <code>datatype</code> is an Atomic URL, the <code>classtype</code> defines which class(es?) is (are?) acceptable.</li>
</ul>
<pre><code class="language-ndjson">[&quot;https://example.com/properties/createdAt&quot;,&quot;https://atomicdata.dev/property/shortname&quot;,&quot;createdAt&quot;]
[&quot;https://example.com/properties/createdAt&quot;,&quot;https://atomicdata.dev/property/datatype&quot;,&quot;https://atomicdata.dev/datatype/datetime&quot;]
</code></pre>
<h2><a class="header" href="#datatype" id="datatype">Datatype</a></h2>
<p><em>URL: <code>https://atomicdata.dev/classes/Datatype</code></em></p>
<p>A Datatype specifies how a <code>Value</code> value should be interpreted.
Datatypes are concepts such as <code>boolean</code>, <code>string</code>, <code>integer</code>.
Since DataTypes can be linked to, you dan define your own.
However, using non-standard datatypes limits how many applications will know what to do with the data.</p>
<p>Properties:</p>
<ul>
<li><code>description</code> - (required, AtomicURL, TranslationBox) how the datatype functions.</li>
<li><code>stringSerialization</code> - (required, AtomicURL, TranslationBox) how the datatype should be parsed / serialized as an UTF-8 string</li>
<li><code>stringExample</code> - (required, string) an example <code>stringSerialization</code> that should be parsed correctly</li>
<li><code>binarySerialization</code> - (optional, AtomicURL, TranslationBox) how the datatype should be parsed / serialized as a byte array.</li>
<li><code>binaryExample</code> - (optional, string) an example <code>binarySerialization</code> that should be parsed correctly. Should have the same contents as the stringExample. Required if binarySerialization is present on the DataType.</li>
</ul>
<h2><a class="header" href="#class" id="class">Class</a></h2>
<p><em>URL: <code>https://atomicdata.dev/classes/Class</code></em></p>
<p>A Class is an abstract type of Resource, such as <code>Person</code>.
It is convention to use an Uppercase in its URI.
Note that in Atomic Data, a Resource can have several Classes - not just a single one.
If you need to set more complex constraints to your Classes (e.g. maximum string length, Properties that depend on each other), check out <a href="https://www.w3.org/TR/shacl/">SHACL</a>.</p>
<p>Properties:</p>
<ul>
<li><code>shortname</code> - (required, Slug) a short string shorthand.</li>
<li><code>description</code> - (required, AtomicURL, TranslationBox) human readable explanation of what the Class represents.</li>
<li><code>requires</code> - (optional, ResourceArray, Property) a list of Properties that are required. If absent, none are required. These SHOULD have unique shortnames.</li>
<li><code>recommends</code> - (optional, ResourceArray, Property) a list of Properties that are recommended. These SHOULD have unique shortnames.</li>
<li><code>deprecatedProperties</code> - (optional, ResourceArray, Property) - a list of Properties that should no longer be used.</li>
</ul>
<!-- Maybe remove this next one? -->
<!-- - `disallowedProperties` - (optional, ResourceArray) a list of Properties that are not allowed.  If absent, all are allowed. -->
<!-- What are the consequences of this? How to deal with this field if there are more classes in aSSubject? -->
<!-- - `allowedProperties` - (optional, ResourceArray) a list of Properties that are allowed. If absent, none are required. -->
<p>A resource indicates it is an <em>instance</em> of that class by adding a <code>https://atomicdata.dev/properties/isA</code> Atom.</p>
<p>Example:</p>
<pre><code class="language-ndjson">[&quot;https://example.com/classes/Person&quot;,&quot;https://atomicdata.dev/properties/isA&quot;,&quot;https://atomicdata.dev/classes/Class&quot;]
[&quot;https://example.com/classes/Person&quot;,&quot;https://atomicdata.dev/properties/recommends&quot;,&quot;https://example.com/classes/Person/recommends&quot;]
[&quot;https://example.com/classes/Person/recommends&quot;,&quot;https://atomicdata.dev/properties/isA&quot;,&quot;https://atomicdata.dev/dataTypes/ResourceArray&quot;]
</code></pre>
<h1><a class="header" href="#atomic-schema-datatypes" id="atomic-schema-datatypes">Atomic Schema: Datatypes</a></h1>
<p>The Atomic Datatypes consist of some of the most commonly used <a href="schema/classes.html#Datatype">Datatypes</a>.</p>
<h2><a class="header" href="#slug" id="slug">Slug</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/slug</code></em></p>
<p>A string with a limited set of allowed characters, used in IDE / Text editor context.
Only letters, numbers and dashes are allowed.</p>
<p>Regex: <code>^[a-z0-9]+(?:-[a-z0-9]+)*$</code></p>
<h2><a class="header" href="#atomic-url" id="atomic-url">Atomic URL</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/atomicURL</code></em></p>
<p>A URL that should resolve to an <a href="schema/../core/concepts.html#Resource">Atomic Resource</a>.</p>
<h2><a class="header" href="#uri" id="uri">URI</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/URI</code></em></p>
<p>A Uniform Resource Identifier, preferably a URL (i.e. an URI that can be fetched).
Could be HTTP, HTTPS, or any other type of schema.</p>
<h2><a class="header" href="#string" id="string">String</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/string</code></em></p>
<p>UTF-8 String, no max character count.
Newlines use backslash escaped <code>\n</code> characters.
Should not contain language specific data, use a <a href="schema/translations.html">TranslationBox</a> instead.</p>
<p>e.g. <code>String time! \n Second line!</code></p>
<h2><a class="header" href="#markdown" id="markdown">Markdown</a></h2>
<p><em>URL: <code>https://https://atomicdata.dev/datatypes/markdown</code></em></p>
<p>A markdown string, using the <a href="https://commonmark.org/">CommonMark syntax</a>.
UTF-8 formatted, no max character count, newlines are <code>\n</code>.</p>
<p>e.g.</p>
<pre><code class="language-md"># Heading

Paragraph with [link](https://example.com).
</code></pre>
<h2><a class="header" href="#integer" id="integer">Integer</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/integer</code></em></p>
<p>Signed Integer, max 64 bit.
Max value: <a href="https://en.wikipedia.org/wiki/9,223,372,036,854,775,807"><code>9223372036854775807</code></a></p>
<p>e.g. <code>-420</code></p>
<h2><a class="header" href="#float" id="float">Float</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/float</code></em></p>
<p>Number with a comma.
Max value: <a href="https://en.wikipedia.org/wiki/9,223,372,036,854,775,807"><code>9223372036854775807</code></a></p>
<p>e.g. <code>-420</code></p>
<h2><a class="header" href="#boolean" id="boolean">Boolean</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/boolean</code></em></p>
<p>True or false, one or zero.</p>
<p><strong>String serialization</strong></p>
<p><code>true</code> or <code>false</code>.</p>
<p><strong>Binary serialization</strong></p>
<p>Use a single bit one boolean.</p>
<p>1 for <code>true</code>, or 0 for <code>false</code>.</p>
<h2><a class="header" href="#date" id="date">Date</a></h2>
<p>ISO date <em>without time</em>.
YYYY-MM-DD.</p>
<p>e.g. <code>1991-01-20</code></p>
<h2><a class="header" href="#timestamp" id="timestamp">Timestamp</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/timestamp</code></em></p>
<p>Similar to <a href="https://www.unixtimestamp.com/">Unix Timestamp</a>.
Milliseconds since midnight UTC 1970 jan 01 (aka the <a href="https://en.wikipedia.org/wiki/Unix_time">Unix Epoch</a>).
Use this for most DateTime fields.
Signed 64 bit integer (instead of 32 bit in Unix systems).</p>
<p>e.g. <code>1596798919</code> (= 07 Aug 2020 11:15:19)</p>
<h2><a class="header" href="#resourcearray" id="resourcearray">ResourceArray</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/resourceArray</code></em></p>
<p>Sequential, ordered list of Atomic URIs.
Serialized as a JSON array with strings.
Note that other types of arrays are not included in this spec, but can be perfectly valid.
(<a href="schema/">discussion</a>)</p>
<ul>
<li>e.g. <code>[&quot;https://example.com/1&quot;, &quot;https://example.com/1&quot;]</code></li>
</ul>
<h1><a class="header" href="#atomic-translations" id="atomic-translations">Atomic Translations</a></h1>
<p>Dealing with translations can be hard.
(<a href="https://github.com/ontola/atomic-data/issues/6">See discussion on this subject here.</a>)</p>
<h2><a class="header" href="#translationbox" id="translationbox">TranslationBox</a></h2>
<p><em>URL: <code>https://atomicdata.dev/classes/TranslationBox</code></em></p>
<p>A TranslationBox is a collection of translated strings, uses to provide multiple translations.
It has a long list of optional properties, each corresponding to some language.
Each possible language Property uses the following URL template: <code>https://atomicdata.dev/languages/{langguageTag}</code>.
Use a <a href="http://www.rfc-editor.org/rfc/bcp/bcp47.txt">BCP 47</a> language tag, e.g. <code>nl</code> or <code>en-US</code>.</p>
<p>For example:</p>
<pre><code class="language-ndjson">[&quot;https://example.com/john&quot;,&quot;https://example.com/lifestory&quot;,&quot;https://example.com/johns/lifestory&quot;]
[&quot;https://example.com/johns/lifestory&quot;,&quot;https://atomicdata.dev/langs/en-US&quot;,&quot;Well, John was born and later he died.&quot;]
[&quot;https://example.com/johns/lifestory&quot;,&quot;https://atomicdata.dev/langs/nl&quot;,&quot;Tsja, John werd geboren en stierf later.&quot;]
</code></pre>
<p>Every single property used for Translation strings are instances of the Translation class.</p>
<p>A translation string uses the <a href="https://https://atomicdata.dev/datatypes/MDString">MDString</a> datatype, which means it allows Markdown syntax.</p>
<h1><a class="header" href="#atomic-schema-faq" id="atomic-schema-faq">Atomic Schema FAQ</a></h1>
<h2><a class="header" href="#how-do-i-create-a-property-that-supports-multiple-datatypes" id="how-do-i-create-a-property-that-supports-multiple-datatypes">How do I create a Property that supports multiple Datatypes?</a></h2>
<p>A property only has one single Datatype.
However, feel free to create a new kind of Datatype that, in turn, refers to other Datatypes.
Perhaps Generics, or Option like types should be part of the Atomic Base Datatypes.</p>
<h2><a class="header" href="#how-should-a-client-deal-with-shortname-collisions" id="how-should-a-client-deal-with-shortname-collisions">How should a client deal with Shortname collisions?</a></h2>
<p>Atomic Data guarantees Subject-Property uniqueness, which means that Valid Resources are guaranteed to have only one of each Property.
Properties offer Shortnames, which are short strings.
These strings SHOULD be unique inside Classes, but these are not guaranteed to be unique inside all Resources.
Note that Resources can have multiple Classes, and through that, they can have colliding Shortnames.
Resources are also free to include Properties from other Classes, and their Shortnames, too, might collide.</p>
<p>For example:</p>
<pre><code class="language-ndjson">[&quot;https://example.com/people/123&quot;, &quot;https://example.com/name&quot;, &quot;John&quot;]
[&quot;https://example.com/people/123&quot;, &quot;https://somepage.example.com/name&quot;, &quot;John&quot;]
</code></pre>
<p>Let's assume that <code>https://somepage.example.com/name</code> and <code>https://example.com/name</code> are Properties that have the Shortname: <code>name</code>.</p>
<p>What if a client tries something such as <code>people123.name</code>?
To consistently return a single value, we need some type of <em>precedence</em>:</p>
<ol>
<li>The earlier Class mentioned in the <code>class</code> Property of the resource. Resources can have multiple classes, but they appear in an ordered ResourceArray. Classes, internally SHOULD have no key collisions in required and recommended properties, which means that they might have. If these exist internally, sort the properties from A-Z.</li>
</ol>
<!-- This  -->
<ol>
<li>When the Properties are not part of any of the mentioned Classes, use Alphabetical sorting of the Property URL.</li>
</ol>
<p>When shortname collisions are possible, it's recommended to not use the shortname, but use the URL of the Property:</p>
<pre><code>people123.&quot;https://example.com/name&quot;
</code></pre>
<h2><a class="header" href="#atomic-data-uses-a-lot-of-links-how-do-you-deal-with-links-that-dont-work" id="atomic-data-uses-a-lot-of-links-how-do-you-deal-with-links-that-dont-work">Atomic Data uses a lot of links. How do you deal with links that don't work?</a></h2>
<ol>
<li>Use URIs schemes that use content dressing, such as IPFS URIs.</li>
</ol>
<h2><a class="header" href="#whats-a-uri-and-whats-a-url" id="whats-a-uri-and-whats-a-url">What's a URI, and what's a URL?</a></h2>
<p>URI stands for Unique Resource Identifier</p>
<h2><a class="header" href="#how-does-atomic-schema-relate-to-shacl--shex--owl--rdfs" id="how-does-atomic-schema-relate-to-shacl--shex--owl--rdfs">How does Atomic Schema relate to SHACL / SheX / OWL / RDFS?</a></h2>
<p>These RDF ontologies are extremely powerful, well-documented and versatile.</p>
<p>Atomic Schema does <em>not</em> aim to be an formal ontological semantic framework - it is way too simple for that.
It's just a simple modeling tool.</p>
<h1><a class="header" href="#atomic-mutations" id="atomic-mutations">Atomic Mutations</a></h1>
<p>Atomic Mutations is a proposed standard for communicating state changes of <a href="mutations/../core/intro.html">Atomic Data</a>.
It is the part of Atomic Data that is concerned with writing, editing and updating.</p>
<p><em>Disclaimer: This part of the draft spec is highly WIP.</em></p>
<h2><a class="header" href="#design-goals-2" id="design-goals-2">Design goals</a></h2>
<ul>
<li><strong>Event sourced</strong>: Store State changes, as well as the current state. This enables versioning, history playback, undo, audit controls, and more.</li>
<li><strong>Traceable origin</strong>: Every state change should be traceable to an actor and a point in time.</li>
<li><strong>Verifiable</strong>: Have cryptographic proof for every state change.</li>
<li><strong>Decentralized</strong>: Can be used in P2P networks to send mutations from device to device.</li>
<li><strong>Extensible</strong>: The methods are not fixed, and can be added by anyone.</li>
<li><strong>Streamable</strong>: The state changes could be used in streaming context, e.g. a client app that reads data that changes every second.</li>
<li><strong>Pub/Sub</strong>: Easy to subscribe to changes and get notified on changes.</li>
<li><strong>Atomic</strong>: All the Atomic Data design goals also apply here.</li>
</ul>
<h2><a class="header" href="#motivation-1" id="motivation-1">Motivation</a></h2>
<p>So many problems that confine data exchange are the result of thinking in current-state exchange.
State synchronization is often an afterthought, and ... TODO!</p>
<p>Keeping track of where data comes from is essential to knowing whether you can trust it - whether you consider it to be true.
When you want to persist data, that quickly becomes bothersome.
Atomic Data and Atomic Mutations aim to make this easier by using cryptography for ensuring data comes from some particular source, and is therefore trustworthy.</p>
<h2><a class="header" href="#in-short-1" id="in-short-1">In short</a></h2>
<ul>
<li><a href="mutations/concepts.html">Atomic Mutations</a> describe how a Resource <em>was changed</em>.</li>
<li><a href="mutations/concepts.html">Atomic Suggestions</a> suggest how a Resource <em>should be changed</em>.</li>
</ul>
<h1><a class="header" href="#atomic-mutations-concepts" id="atomic-mutations-concepts">Atomic Mutations: Concepts</a></h1>
<h2><a class="header" href="#mutation" id="mutation">Mutation</a></h2>
<p>The smallest possible piece of a state change.
A mutation describes how an Resource should be updated.
Mutations are very similar to Atoms, but they contain more information.
An Atomic Mutation consists of a:</p>
<ul>
<li><code>subject</code> - the Thing that the atom is providing information about. (must be a URI to an Atomic Thing)</li>
<li><code>property</code> - the property of the Thing that the atom is about. (must be a URI to an Atomic Property)</li>
<li><code>value</code> - the new piece of information about the Atom (can be any datatype, as long as its defined by the property)</li>
<li><code>method</code> - How the resource needs to be updated using the Atom. If empty, just replace the current state.</li>
<li><code>hash</code> - The <a href="mutations/versioning.html#Hashing">IPFS URL</a> of the updated version of the resource. If this does not match with your resource, the Mutation is faulty. The hash can be empty if it is sent in</li>
<li><code>date</code> - A timestamp of when the mutation was created.</li>
<li><code>actor</code> - A timestamp of when the mutation was created.</li>
</ul>
<h2><a class="header" href="#ledger" id="ledger">Ledger</a></h2>
<p>A Ledger is an (append-only) log of Mutations.</p>
<ul>
<li><code>mutations</code> (required, ResourceArray) - A list of all the mutations, from old to new.</li>
</ul>
<h2><a class="header" href="#commit" id="commit">Commit</a></h2>
<p>A Commit is a set of Mutations, made by some Actor</p>
<p>TODO!</p>
<h2><a class="header" href="#serialization-with-atomicmutations-ndjson" id="serialization-with-atomicmutations-ndjson">Serialization with AtomicMutations-ndjson</a></h2>
<p>Although Mutations can be communicated with</p>
<p>Work in progress, see <a href="https://github.com/ontola/linked-delta">linked-delta</a>.</p>
<pre><code class="language-ndjson">[&quot;https://example.com/john&quot;, &quot;https://example.com/properties/lastName&quot;, &quot;Mc'Lovin&quot;, &quot;https://purl.org/linked-delta/add&quot;, &quot;AEF1245612F3&quot;]
</code></pre>
<h2><a class="header" href="#streaming-pubsub" id="streaming-pubsub">Streaming (pub/sub)</a></h2>
<p>We're using HexTuples-NDJSON, since that allows for streaming parsing of mutations.</p>
<p>TODO! Something about endpoints / protocol for pub/sub.</p>
<h2><a class="header" href="#base-methods" id="base-methods">Base Methods</a></h2>
<p>See <a href="http://purl.org/linked-delta">linked-delta</a></p>
<h1><a class="header" href="#atomic-suggestions" id="atomic-suggestions">Atomic Suggestions</a></h1>
<p>Atomic Suggestions is a proposed standard that enables decentralized collaboration on resources.
It's basically Git for linked data.
Practically, it should enable right-clicking on any piece of Atomic Data on the web, and suggesting an edit to the owner.</p>
<h2><a class="header" href="#design-goals-3" id="design-goals-3">Design goals</a></h2>
<ul>
<li><strong>Asynchronous collaboration</strong>: Various users can work on the same thing at the same time.</li>
<li><strong>Branching &amp; merging</strong>: Issues that result from async changes (merge conflicts) can be resolved.</li>
</ul>
<h2><a class="header" href="#concepts" id="concepts">Concepts</a></h2>
<h3><a class="header" href="#fork" id="fork">Fork</a></h3>
<p>Forking is the first step to making a suggestion.
Forking refers to:</p>
<ol>
<li>copying some resource</li>
<li>changing the subject URL to some URL that you control</li>
<li>adding a reference to the original URL using the <code>atomic:originalSubject</code> Property.</li>
</ol>
<p>The newly created copy with the different URL is a <em>Fork</em>.
Since the Fork is a resource that you own (see <a href="mutations/ownership.html">Ownership</a>), you can make changes to is.</p>
<p>Whenever you make changes, the app making the changes <em>should</em> keep track of them as Atomic Mutations.
These Mutations make it easier to apply (small) changes to (large) resources, even when multiple people are working on the same thing at the same time.</p>
<h3><a class="header" href="#suggestion" id="suggestion">Suggestion</a></h3>
<p>When you've forked some resource and made some changes, you can Suggest these changes to the original owner.
This is done by sending an HTTP POST request containing the mutations to the Owner URL.</p>
<p>A Suggestion is a (set of?) Mutation(s?) that is proposed to be appended to some Ledger.
The important difference between a Suggestion and a Mutation, is that a Mutation has been verified, signed and approved by the Controller.</p>
<h3><a class="header" href="#controller" id="controller">Controller</a></h3>
<p>The actor (person / organization) that is in control of a specific Resource and its mutations.</p>
<h3><a class="header" href="#inbox" id="inbox">Inbox</a></h3>
<p>An Inbox represents a resource that contains incoming Suggestions.
It's similar to an e-mail inbox.</p>
<h2><a class="header" href="#protocol" id="protocol">Protocol</a></h2>
<p>Let's</p>
<pre><code class="language-http">POST example.com/sarah HTTP/1.1
Host: foo.example
Content-Type: application/ad3-ndjson

[&quot;https://example.com/sarah&quot;,&quot;https://example.com/description&quot;,&quot;&quot;]
</code></pre>
<h1><a class="header" href="#atomic-data-versioning" id="atomic-data-versioning">Atomic Data Versioning</a></h1>
<p>When Atomic Mutations are applied to some Resource, the resource will change.
However, its identifier (the Subject) will often remain the same.</p>
<ul>
<li>Versioned representations should provide a link to the authority that might update it, and a link to where the latest version can be found.</li>
<li>The latest version should have a link to its permanent version.</li>
<li>Should <a href="mutations/../interoperability/ipfs.html">IPFS</a> content-hash URLs be used for Versioned resources?</li>
</ul>
<h2><a class="header" href="#versioned-resources" id="versioned-resources">Versioned Resources</a></h2>
<p>Properties:</p>
<!-- Maybe this is not required, if we assume that the subject URL should always show the latest? -->
<ul>
<li>latest: (ResourceArray, optional)</li>
<li>versions: (ResourceArray, optional)</li>
<li>currentVersion: (ResourceURL, required)</li>
</ul>
<h2><a class="header" href="#static-resource" id="static-resource">Static Resource</a></h2>
<p>A static resource has a <em>content addressable</em> URL, which means that its URL will never change.</p>
<h2><a class="header" href="#hashing" id="hashing">Hashing</a></h2>
<ul>
<li>Serialize all Atoms of the Subject (the entire Resource) as Atomic-NDJSON</li>
<li>Sort all lines (every atom) alphabetically</li>
</ul>
<h1><a class="header" href="#interoperability-relation-to-other-technology" id="interoperability-relation-to-other-technology">Interoperability: Relation to other technology</a></h1>
<p>Atomic data is designed to be highly interoperable.</p>
<h2><a class="header" href="#data-formats" id="data-formats">Data formats</a></h2>
<p>It is possible to convert Atomic to many types of serialization formats.</p>
<ul>
<li><a href="interoperability/rdf.html">RDF</a>: some RDF can be automatically converted into valid Atomic data.</li>
<li><a href="interoperability/json.html">JSON</a>: JSON requires a mapping to Atomic Properties, and explicit</li>
</ul>
<h2><a class="header" href="#protocols" id="protocols">Protocols</a></h2>
<ul>
<li><a href="interoperability/ipfs.html">IPFS</a>: Content-based addressing to prevent 404s and centralization</li>
</ul>
<h1><a class="header" href="#how-does-atomic-data-relate-to-rdf" id="how-does-atomic-data-relate-to-rdf">How does Atomic Data relate to RDF?</a></h1>
<p>RDF (the <a href="https://www.w3.org/TR/rdf-primer/">Resource Description Framework</a>) is a W3C specification from 1999 that describes the original data model for linked data.
It is the forerunner of Atomic Data, and is therefore highly similar in its model.
Both heavily rely on using URLs, and both have a fundamentally simple and uniform model for data statements.
Both view the web as a single, connected graph database.
Because of that, Atomic Data is also highly compatible with RDF - <strong>all Atomic Data can be converted into valid RDF</strong>.
Atomic Data can be thought of as a <strong>more constrained, type safe version of RDF</strong>.
However, it does differ in some fundamental ways.</p>
<ul>
<li>Atomic calls the three parts of a Triple <code>subject</code>, <code>property</code> and <code>value</code>, instead of <code>subject</code>, <code>predicate</code>, <code>object</code>.</li>
<li>Atomic does not support having multiple statements with the same <code>&lt;subject&gt; &lt;predicate&gt;</code>, every combination should be unique.</li>
<li>Atomic has no difference between <code>literal</code>, <code>named node</code> and <code>blank node</code> objects - these are all <code>values</code>, but with different datatypes.</li>
<li>Atomic uses <code>paths</code> instead of <code>blank nodes</code></li>
<li>Atomic requires URL (not URI) values in its <code>subjects</code> and <code>predicates</code> (properties), which means that they should be resolvable.</li>
<li>Atomic only allows those who control a resource's <code>subject</code> URL endpoint to edit the data. This means that you can't add triples about something that you don't control.</li>
<li>Atomic has no separate <code>datatype</code> field, but it requires that <code>Properties</code> (the resources that are shown when you follow a <code>predicate</code> value) specify a datatype</li>
<li>Atomic has no separate <code>language</code> field, but it does support <a href="interoperability/../schema/translations.html">Translation Resources</a>.</li>
<li>Atomic has a native Event (state changes) model (<a href="interoperability/../mutations/intro.html">Atomic Mutations</a>), which enables communication of state changes</li>
<li>Atomic has a native Schema model (<a href="interoperability/../schema/intro.html">Atomic Schema</a>), which helps developers to know what data types they can expect (string, integer, link, array)</li>
</ul>
<h2><a class="header" href="#why-these-changes" id="why-these-changes">Why these changes?</a></h2>
<p>I love RDF, and have been working with it for quite some time now.
Using URIs (and more-so URLs, which are URIs that can be fetched) for everything is a great idea, since it helps with interoperability and enables truly decentralized knowledge graphs.
However, some of the characteristics of RDF might have contributed to its relative lack of adoption.</p>
<h3><a class="header" href="#its-too-hard-to-select-a-specific-value-object-in-rdf" id="its-too-hard-to-select-a-specific-value-object-in-rdf">It's too hard to select a specific value (object) in RDF</a></h3>
<p>For example, let's say I want to render someone's birthday:</p>
<pre><code class="language-ttl">&lt;example:joep&gt; &lt;schema:birthDate&gt; &quot;1991-01-20&quot;^^xsd:date
</code></pre>
<p>Rendering this item might be as simple as fetching the subject URL, filtering by predicate URL, and parsing the <code>object</code> as a date.</p>
<p>However, this is also valid RDF:</p>
<pre><code class="language-ttl">&lt;example:joep&gt; &lt;schema:birthDate&gt; &quot;1991-01-20&quot;^^xsd:date &lt;example:someNamedGraph&gt;
&lt;example:joep&gt; &lt;schema:birthDate&gt; &lt;example:birthDateObject&gt; &lt;example:someOtherNamedGraph&gt;
&lt;example:joep&gt; &lt;schema:birthDate&gt; &quot;20th of januari 1991&quot;@en &lt;example:someNamedGraph&gt;
&lt;example:joep&gt; &lt;schema:birthDate&gt; &quot;20 januari 1991&quot;@nl &lt;example:someNamedGraph&gt;
&lt;example:joep&gt; &lt;schema:birthDate&gt; &quot;2000-02-30&quot;^^xsd:date &lt;example:someNamedGraph&gt;
</code></pre>
<p>Now things get more complicated if you just want to select the original birthdate value:</p>
<ol>
<li><strong>Select the named graph</strong>. The triple containing that birthday may exist in some named graph different from the <code>subject</code> URL, which means that I first need to identify and fetch that graph.</li>
<li><strong>Select the subject</strong>.</li>
<li><strong>Select the predicate</strong>.</li>
<li><strong>Select the datatype</strong>. You probably need a specific datatype (in this case, a Date), so you need to filter the triples to match that specific datatype.</li>
<li><strong>Select the language</strong>. Same could be true for language, too, but that is not necessary in this birthdate example.</li>
<li><strong>Select the specific triple</strong>. Even after all our previous selectors, we <em>still</em> might have multiple values. How do I know which is the triple I'm supposed to use?</li>
</ol>
<p>To be fair, with a lot of RDF data, only steps 2 and 3 are needed, since there are often no <code>subject-predicate</code> collisions.
And if you <em>control</em> the data of the source, you can set any constraints that you like, inlcluding <code>subject-predicate</code> uniqueness.
But if you're building a system that uses arbitrary RDF, that system also needs to deal with steps 1,4,5 and 6.
That often means writing a lot of conditionals and other client-side logic to get the value that you need.
It also means that serializing to a format like JSON becomes complicated - you can't just map predicates to keys - you might get collisions.
Oh, and you can't use key-value stores for storing RDF, at least not in a trivial way.
This complexity is the direct result of the lack of <code>subject-predicate</code> uniqueness.</p>
<p>As a developer who uses RDF data, I want to be able to do something like this:</p>
<pre><code class="language-js">// Fetches the resource
const joep = get(&quot;https://example.com/person/joep&quot;)

// Returns the value of the birthDate atom
console.log(joep.birthDate()) // =&gt; Date(1991-01-20)
// Fetches the employer relation at possibly some other domain, checks that resource for a property with the 'name' shortkey
console.log(joep.employer().name()) // =&gt; &quot;Ontola.io&quot;
</code></pre>
<p>Basically, I'd like to use all knowledge of the world as if it were a big JSON object.
Being able to do that, requires some things that are present in JSON, and some things that are present in RDF</p>
<ul>
<li>Traverse data on various domains (which is already possible with RDF)</li>
<li>Have <a href="interoperability/rdf.html#subject-predicate-uniqueness">unique <code>subject-predicate</code> combinations</a> (which is default in JSON)</li>
<li>Map properties URLs to keys (which often requires local mapping with RDF, e.g. in JSON-LD)</li>
<li>Link properties to datatypes (which is possible with ontologies like SHACL / SHEX)</li>
</ul>
<h3><a class="header" href="#less-focus-on-semantics-more-on-usability" id="less-focus-on-semantics-more-on-usability">Less focus on semantics, more on usability</a></h3>
<p>One of the core ideas of the semantic web, is that anyone should be able to say anything about anything, using semantic triples.
This is one of the reasons why it can be so hard to select a specific value in RDF.
When you want to make all graphs mergeable (which is a great idea), but also want to allow anyone to create any triples about any subject, you get <code>subject-predicate</code> non-uniqueness.
For the Semantic Web, having <em>semantic</em> triples is great.
For linked data, and connecting datasets, having atomic triples (with unique <code>subject-predicate</code> combinations) seems preferable.
Atomic Data chooses a more constrained approach, which makes it easier to use the data, but at the cost of some expressiveness.</p>
<h3><a class="header" href="#changing-the-names" id="changing-the-names">Changing the names</a></h3>
<p>RDF's <code>subject</code>, <code>predicate</code> and <code>object</code> terminology can be confusing to newcomers, so Atomic Data uses <code>subject</code>, <code>property</code>, <code>value</code>.
This more closely resembles common CS terminology. (<a href="https://github.com/ontola/atomic-data/issues/3">discussion</a>)</p>
<h3><a class="header" href="#subject--predicate-uniqueness" id="subject--predicate-uniqueness">Subject + Predicate uniqueness</a></h3>
<p>In RDF, it's very much possible for a graph to contain multiple statements that share both a <code>subject</code> and a <code>predicate</code>.
One of the reasons this is possible, is because RDF graphs should always be mergeable.
However, this introduces some extra complexity for data users.
Whereas most languages and datatypes have <code>key-value</code> uniqueness that allow for unambiguous value selection, RDF clients have to deal with the possibility that multiple triples with the same <code>subject-predicate</code> combination might exist.</p>
<p>Atomic Data requires <code>subject-property</code> uniqueness, which means that this is no longer an issue for clients.
However, in order to guarantee this, and still retain <em>graph merge-ability</em> we also need to limit who creates statements about a subject:</p>
<h3><a class="header" href="#limiting-subject-usage" id="limiting-subject-usage">Limiting subject usage</a></h3>
<p>RDF allows that <code>anne.com</code> creates and hosts statements about the subject <code>john.com</code>.
In other words, domain A creates statements about domain B.
It allows anyone to say anything about any subject, thus allowing for extending data that is not under your control.</p>
<p>For example, developers at both Ontola and Inrupt (two companies that work a lot with RDF) use this feature to extend the Schema.org ontology with translations.
This means they can still use standards from Schema.org, and have their own translations of these concepts.</p>
<p>However, I think this is a flawed approach.
In the example above, two companies are adding statements about a subject.
In this case, both are adding translations.
They're doing the same work twice.
And as more and more people will use that same resource, they will be forced to add the same translations, again and again.</p>
<p>I think one of the core perks of linked data, is being able to make your information highly re-usable.
When you've created statements about an external thing, these statements are hard to re-use.</p>
<p>A different</p>
<p>This means that someone using RDF data about domain B cannot know that domain B is actually the source of the data.
Knowing <em>where data comes from</em> is one of the great things about URIs, but RDF does not require that you can think of subjects as the source of data.
Many subjects in RDF don't actually resolve to all the known triples of the statement.
It would make the conceptual model way simpler if statements about a subject could only be made from the source of the domain owner of the subject.
When triples are created about a resource in a place other than where the subject is hosted, these triples are hard to share.</p>
<p>The way RDF projects deal with this, is by using <em>named graphs</em>.
As a consequence, all systems that use these triples should keep track of another field for every atom.
To make things worse, it makes <code>subject-predicate</code> <em>impossible</em> to guarantee.
That's a high price to pay.</p>
<p>I've asked two colleagues working on RDF about this constraint, and both were critical.
The reason</p>
<h3><a class="header" href="#no-more-literals--named-nodes" id="no-more-literals--named-nodes">No more literals / named nodes</a></h3>
<p>In RDF, an <code>object</code> can either be a <code>named node</code>, <code>blank node</code> or <code>literal</code>. A <code>literal</code> has a <code>value</code>, a <code>datatype</code> and an optional <code>language</code> (if the <code>literal</code> is a string).
Although RDF statements are often called <code>triples</code>, a single statement can consist of five fields: <code>subject</code>, <code>predicate</code>, <code>object</code>, <code>language</code>, <code>datatype</code>.
Having five fields is way more than most information systems. Usually we have just <code>key</code> and <code>value</code>.
This difference leads to compatibility issues when using RDF in applications.
In practice, clients have to run a lot of checks before they can use the data - which makes RDF in most contexts harder to use than something such as JSON.</p>
<p>Atomic Data drops the <code>named node</code> / <code>literal</code> distinction.
We just have <code>values</code>, and they are interpreted by looking at the <code>datatype</code>, which is defined in the <code>property</code>.
When a value is a URL, we don't call it a named node, but we simply use a URL datatype.</p>
<h3><a class="header" href="#requiring-urls" id="requiring-urls">Requiring URLs</a></h3>
<p>RDF allows any type of URIs for <code>subject</code> and <code>predicate</code> value, which means they can be URLs, but don't have to be. This means they don't always resolve, or even function as locators. The links don't work, and that restricts how useful the links are. Atomic Data takes a different approach: these links MUST Resolve. Requiring Properties to resolve is part of what enables the type system of Atomic Schema - they provide the <code>shortname</code> and <code>datatype</code>.</p>
<p>Requiring URLs makes things easier for data users, at the cost of the data producer.
With Atomic Data, the data producer MUST offer the triples at the URL of the subject.
This is a challenge - especially with the current (lack of) tooling.</p>
<p>However - making sure that links <em>actually work</em> offer tremendous benefits for data consumers, and that advantage is often worth the extra trouble.</p>
<h3><a class="header" href="#replace-blank-nodes-with-paths" id="replace-blank-nodes-with-paths">Replace blank nodes with paths</a></h3>
<p><code>blank nodes</code> are resources with identifiers that exist only locally.
They make life easier for data producers, who can easily create nested resources without having to mint all the URLs.
In most data models, blank nodes are the default.
For example, we nest JSON object without thinking twice.</p>
<p>Unfortunately, blank nodes tend to make things harder for clients.
These clients will now need to keep track of where these blank nodes came from, and they need to create internal identifiers that will not collide.
Cache invalidation with blank nodes also becomes a challenge.
To make this a bit easier, Atomic Data introduces a new way of dealing with names of things that you have not given a URL yet: <a href="interoperability/../core/paths.html">Atomic Paths</a>.</p>
<p>Since Atomic Data has <code>subject-predicate</code> uniqueness, we can use the <em>path</em> of triples as a unique identifier:</p>
<pre><code>https://example.com/john https://schema.org/employer
</code></pre>
<p>So the way an Atomic Data store should store <code>blank nodes</code>, is simply as an atom with a Path as its URL.
This prevents collisions and still makes it easy to point to a specific value.</p>
<p>Serialization formats are free to use nesting to denote paths - which means that it is not necessary to include these path strings explicitly in most serialization formats.</p>
<p>You can read more about Atomic Paths <a href="interoperability/../core/paths.html">here</a>.</p>
<h3><a class="header" href="#combining-datatype-and-predicate" id="combining-datatype-and-predicate">Combining datatype and predicate</a></h3>
<p>Having both a <code>datatype</code> and a <code>predicate</code> value can lead to confusing situations.
For example, the <a href="https://schema.org/dateCreated"><code>schema:dateCreated</code></a> Property requires an ISO DateTime string (according to the schema.org definition), but using a value <code>true</code> with an <code>xsd:boolean</code> datatype results in perfectly valid RDF.
This means that client software using triples with a <code>schema:dateCreated</code> predicate cannot safely assume that its value will be a DateTime.
So if the client wants to use <code>schema:dateCreated</code> values, the client must also specify which type of data it expects, check the datatype field of every Atom and provide logic for when these don't match.
Also important combining <code>datatype</code> and <code>predicate</code> fits the model of most programmers and languages better - just look at how every single struct / model / class / shape is defined in programming languages: <code>key: datatype</code>.
This is why Atomic Data requires that a <code>predicate</code> links to a Property which must have a <code>Datatype</code>.</p>
<h3><a class="header" href="#adding-shortnames-slugs--keys-in-properties" id="adding-shortnames-slugs--keys-in-properties">Adding shortnames (slugs / keys) in Properties</a></h3>
<p>Using full URI strings as keys (in RDF <code>predicates</code>) results in a relatively clunky Developer Experience.
Consider the short strings that developers are used to in pretty much all languages and data formats (<code>object.attribute</code>).
Adding a <em>required</em> / tightly integrated key mapping (from long URLs to short, simple strings) in Atomic Properties solves this issue, and provides developers a way to write code like this: <code>someAtomicPerson.bestFriend.name =&gt; &quot;Britta&quot;</code>.
Although the RDF ecosystem does have some solutions for this (@context objects in JSON-LD, @prefix mappings, the @ontologies library), these prefixes are not defined in Properties themselves and therefore are often defined locally or separate from the ontology, which means that developers have to manually map them most of the time.
This is why Atomic Data introduces a <code>shortname</code> field in Properties, which forces modelers to choose a 'key' that can be used in ORM contexts.</p>
<h3><a class="header" href="#adding-native-arrays" id="adding-native-arrays">Adding native arrays</a></h3>
<p>RDF lacks a clear solution for dealing with <a href="https://ontola.io/blog/ordered-data-in-rdf/">ordered data</a>, resulting in confusion when developers have to create lists of content.
Adding an Array data type as a base data type helps solve this. (<a href="https://github.com/ontola/atomic-data/issues/4">discussion</a>)</p>
<h3><a class="header" href="#adding-a-native-mutation-standard" id="adding-a-native-mutation-standard">Adding a native mutation standard</a></h3>
<p>There is no integrated standard for communicating state changes.
Although <a href="https://github.com/ontola/linked-delta">linked-delta</a> and <a href="https://afs.github.io/rdf-delta/">rdf-delta</a> do exist, they aren't referred to by the RDF spec.
I think developers need guidance when learning a new system such as RDF, and that's why <a href="interoperability/../mutations/intro.html">Atomic Mutations</a> is included in this book.</p>
<h3><a class="header" href="#adding-a-schema-language" id="adding-a-schema-language">Adding a schema language</a></h3>
<p>A schema language is necessary to constrain and validate instances of data.
This is very useful when creating domain-specific standards, which can in turn be used to generate forms or language-specific types / interfaces.
Shape validations are already possible in RDF using both <a href="https://www.w3.org/TR/shacl/">SHACL</a> and <a href="https://shex.io/">SHEX</a>, and these are both very powerful and well designed.</p>
<p>However, with Atomic Data, I'm going for simplicity.
This also means providing an all-inclusive documentation.
I want people who read this book to have a decent grasp of creating, modeling, sharing, versioning and querying data.
It should provide all information that most developers (new to linked data) will need to get started quickly.
Simply linking to SHACL / SHEX documentation could be intimidating for new developers, who simply want to define a simple shape with a few keys and datatypes.</p>
<p>Also, SHACL requires named graphs (which are not specified in Atomic Data) and SHEX requires a new serialization format, which might limit adoption.
Atomic Data has some unique constrains (such as subject-predicate uniqueness) which also might make things more complicated when using SHEX / SHACL.</p>
<p><em>However</em>, it is not the intention of Atomic Data to create a modeling abstraction that is just as powerful as the ones mentioned above, so perhaps it is better to include a SHACL / SHEX tutorial and come up with a nice integration of both worlds.</p>
<h3><a class="header" href="#a-new-name-with-new-docs" id="a-new-name-with-new-docs">A new name, with new docs</a></h3>
<p>Besides the technical reasons described above, I think that there are social reasons to start with a new concept and give it a new name:</p>
<ul>
<li>The RDF vocabulary is intimidating. When trying to understand RDF, you're likely to traverse many pages with new concepts: <code>literal</code>, <code>named node</code>, <code>graph</code>, <code>predicate</code>, <code>named graph</code>, <code>blank node</code>... The core specification provides a formal description of these concepts, but fails to do this in a way that results in quick understanding and workable intuitions. Even experienced RDF developers tend to be confused about the nuances of the core model.</li>
<li>There is a lack of learning resources that provide a clear, complete answer to the lifecycle of RDF data: modeling data, making data, hosting it, fetching it, updating it. Atomic Data aims to provide an opinionated answer to all of these steps. It feels more like a one-stop-shop for questions that developers are likely to encounter, whilst keeping the extendability.</li>
<li>All Core / Schema URLs should resolve to simple, clear explanations with both examples and machine readable definitions. Especially the Property and Class concepts.</li>
<li>The Semantic Web community has had a lot of academic attention from formal logic departments, resulting in a highly developed standard for knowledge modeling: the Web Ontology Language (OWL). While this is mostly great, its open-world philosophy and focus on reasoning abilities can confuse developers who are simply looking for a simple way to share models in RDF.</li>
</ul>
<h2><a class="header" href="#convert-rdf-to-atomic-data" id="convert-rdf-to-atomic-data">Convert RDF to Atomic Data</a></h2>
<ul>
<li><strong>All the <code>subject</code> URLs MUST actually resolve, and return all triples about that subject</strong>. All <code>blank nodes</code> should be converted into URLs. Atomic Data tools might help to achieve this, for example by hosting the data.</li>
<li><strong>All <code>predicates</code> SHOULD resolve to Atomic Properties, and these SHOULD have a <code>datatype</code></strong>. You will probably need to change predicate URLs to Atomic Property URLs, or update the things that the predicate points to to include the required Atomic Property items (e.g. having a Datatype and a Shortname). This also means that the <code>datatype</code> in the original RDF statement can be dropped.</li>
<li>Literals with a <code>language</code> tag are converted to TranslationBox resources, which also means their identifiers must be created. Keep in mind that Atomic Data does not allow for blank nodes, so the TranslationBox identifiers must be URLs.</li>
</ul>
<p>Step by step, it entails:</p>
<ol>
<li>Set up some server to make sure the URLs will resolve.</li>
<li>Create (or find and refer to) Atomic Properties for all the <code>predicates</code>. Make sure they have a DataType and a Shortname.</li>
<li>If you have triples about a subject that you don't control, change the URL to some that you <em>can</em> control, and refer to that external resource.</li>
</ol>
<p>Atomic Data will need <a href="interoperability/../tooling.html">tooling</a> to facilitate in this process.
This tooling should help to create URLs, Properties, and host everything on an easy to use server.</p>
<h2><a class="header" href="#convert-atomic-data-to-rdf" id="convert-atomic-data-to-rdf">Convert Atomic data to RDF</a></h2>
<p>Since all Atomic Data is also valid RDF, it's trivial to convert / serialize Atoms to RDF.
However, contrary to Atomic Data, RDF has optional Language and Datatype elements in every statement.
It is good practice to use these RDF concepts when serializing Atomic Data into Turtle / RDF/XML, or other <a href="https://ontola.io/blog/rdf-serialization-formats/">RDF serialization formats</a>.</p>
<ul>
<li>Convert Atoms with linked <code>TranslationBox</code> Resources to Literals with an <code>xsd:string</code> datatype and the corresponding language in the tag.</li>
<li>Dereference the Property and Datatype from Atomic Properties, and add the URLs in <code>datatypes</code> in RDF statements.</li>
</ul>
<h1><a class="header" href="#how-does-atomic-data-relate-to-json" id="how-does-atomic-data-relate-to-json">How does Atomic Data relate to JSON?</a></h1>
<p>Because JSON is so popular, Atomic Data is designed to be easily serializable to JSON.</p>
<p>Atomic Data is a strict subset of RDF, and the most popular serialization of RDF for JSON data is <a href="https://json-ld.org/">JSON-LD</a>.
All JSON-LD is perfectly valid JSON, but with a couple of handy features.</p>
<h2><a class="header" href="#from-json-to-atomic-data" id="from-json-to-atomic-data">From JSON to Atomic Data</a></h2>
<p>Atomic Data requires a bit more information about pieces of data than JSON tends to contain. Let's take a look at a regular JSON example:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;John&quot;,
  &quot;birthDate&quot;: &quot;1991-01-20&quot;
}
</code></pre>
<p>We need more information to convert this JSON into Atomic Data.
The following things are missing:</p>
<ul>
<li>What is the Subject URL of the resource being described?</li>
<li>What is the Predicate URL of the keys being used? (<code>name</code> and <code>birthDate</code>), and consequentially, how should the values be parsed? What are their DataTypes?</li>
</ul>
<p>We can add this data by adding some <em>@context</em>:</p>
<pre><code class="language-json">{
  &quot;@context&quot;: {
    &quot;name&quot;: &quot;https://example.com/properties/name&quot;,
    &quot;birthDate&quot;: &quot;https://example.com/properties/birthDate&quot;,
    &quot;@id&quot;: &quot;https://example.com/people/john&quot;
  },
  &quot;name&quot;: &quot;John&quot;,
  &quot;birthDate&quot;: &quot;1991-01-20&quot;
}
</code></pre>
<p>The JSON above is called JSON-LD.
It is still perfectly valid JSON, but it contains more information, and in turn can be converted into RDF formats.</p>
<h2><a class="header" href="#from-atomic-data-to-json" id="from-atomic-data-to-json">From Atomic Data to JSON</a></h2>
<p>Since Atomic Schema requires the presence of a <code>key</code> slug in Properties, converting Atomic Data to JSON results in dev-friendly objects with nice shorthands.</p>
<pre><code class="language-ndjson">[&quot;https://example.com/john&quot;,&quot;https://example.com/properties/lastname&quot;,&quot;Houdini&quot;]
[&quot;https://example.com/john&quot;,&quot;https://example.com/properties/bestFriend&quot;,&quot;https://example.com/sarah&quot;]
</code></pre>
<p>Can be automatically converted to:</p>
<pre><code class="language-json">{
  &quot;@context&quot;: {
    &quot;name&quot;: &quot;https://example.com/properties/lastname&quot;,
    &quot;bestFriend&quot;: &quot;https://example.com/properties/bestFriend&quot;,
  },
  &quot;name&quot;: &quot;John&quot;,
  &quot;bestFriend&quot;: {
    &quot;@id&quot;: &quot;https://example.com/sarah&quot;
  },
}
</code></pre>
<p>The <code>@context</code> object provides a <em>mapping</em> to the original URLs.
The <code>@id</code> key shows that the value should be interpreted as a link (a URI).</p>
<h2><a class="header" href="#json-ld-requirements" id="json-ld-requirements">JSON-LD Requirements</a></h2>
<ul>
<li>Make sure the URLs used in the <code>@context</code> resolve to Atomic Properties.</li>
</ul>
<!-- Not sure about this.. maybe use RDF collections or some other model? -->
<ul>
<li>Convert JSON-LD arrays into ResourceArrays</li>
<li>Creating nested JSON objects is possible (by resolving the identifiers from <code>@id</code> relations), but it is up to the serializer to decide how deep this object nesting should happen.</li>
</ul>
<h2><a class="header" href="#considerations" id="considerations">Considerations</a></h2>
<ul>
<li>Whilst JSON-LD is great for traditional JSON usage (dot.syntax ORM style navigation of objects), it is not great for linked data usage.</li>
</ul>
<h1><a class="header" href="#atomic-data-and-ipfs" id="atomic-data-and-ipfs">Atomic Data and IPFS</a></h1>
<h2><a class="header" href="#what-is-ipfs" id="what-is-ipfs">What is IPFS</a></h2>
<p>IPFS (the InterPlanetary File System) is a standard that enables decentralized file storage and retrieval using content-based identifiers.
Instead of using an HTTP URL like <code>http://example.com/helloworld</code>, it uses the IPFS scheme, such as <code>ipfs:QmX6j9DHcPhgBcBtZsuRkfmk2v7G5mzb11vU9ve9i8vDsL</code>.
IPFS identifies things based on their unique content hash (the long, seemingly random string) using a thing called a Merkle DAG (<a href="https://medium.com/textileio/whats-really-happening-when-you-add-a-file-to-ipfs-ae3b8b5e4b0f#:%7E:text=In%20practice%2C%20content%20addressing%20systems,function%2C%20to%20produce%20a%20digest.&amp;text=From%20raw%20image%20to%20cryptographic%20digest%20to%20content%20id%20(multihash).">this great article</a> explains it nicely).
This is called a <a href="https://github.com/multiformats/cid">CID</a>, or Content ID.
This simple idea (plus some not so simple network protocols) allows for decentralized, temper-proof storage of data.
This fixes some issues with HTTP that are related to its centralized philosophy: no more 404s!</p>
<h2><a class="header" href="#why-is-ipfs-especially-interesting-for-atomic-data" id="why-is-ipfs-especially-interesting-for-atomic-data">Why is IPFS especially interesting for Atomic Data</a></h2>
<p>Atomic Data is highly dependent on the availability of Resources, especially Properties and Datatypes.
These resources are meant to be re-used a lot, and that would make everything expensive.</p>
<h2><a class="header" href="#considerations-using-ipfs-urls" id="considerations-using-ipfs-urls">Considerations using IPFS URLs</a></h2>
<p>They are static, their contents can never change.
This is great for some types of data, but horrible for others.
If you're describing a time-dependent thing (such as a person's job),
If you're describing personal, private information, its also a bad idea to use IPFS, because it's designed to be permanent.
Also, IPFS is not as fast as HTTP - at least for now.</p>
<h2><a class="header" href="#example-of-atomic-data-on-ipfs" id="example-of-atomic-data-on-ipfs">Example of Atomic Data on IPFS</a></h2>
<p>Here's an example, serialized to Atomic-NDJSON:</p>
<p><a href="https://ipfs.io/ipfs/QmX6j9DHcPhgBcBtZsuRkfmk2v7G5mzb11vU9ve9i8vDsL">https://ipfs.io/ipfs/QmX6j9DHcPhgBcBtZsuRkfmk2v7G5mzb11vU9ve9i8vDsL</a></p>
<pre><code class="language-ndjson">[&quot;https://atomicdata.dev/helloworld&quot;,&quot;https://atomicdata.dev/properties/description&quot;,&quot;Hello world!&quot;]
</code></pre>
<h2><a class="header" href="#atomic-data-and-ipld" id="atomic-data-and-ipld">Atomic Data and IPLD</a></h2>
<p>IPLD (not IPFS) stands for InterPlanetary Linked Data, but is not related to RDF.
The scope seems fundamentally different from RDF, too, but I have to read more about this.
TODO!</p>
<h1><a class="header" href="#atomic-graph-validations" id="atomic-graph-validations">Atomic Graph Validations</a></h1>
<p>An Graph is a set of Atoms.
Since Atomic Data is designed to facilitate decentralized data storage, Graphs will often lack information or contain invalid data.
In this section, we define some of these concepts.</p>
<ul>
<li>A <strong>Valid Graph</strong> contains no mismatches between Datatypes from Properties and their usage in Atoms</li>
<li>A <strong>Closed Graph</strong> contains no unfetched outgoing links</li>
<li>A <strong>Verified Graph</strong> contains only Atoms from verified Authors</li>
<li>A <strong>Schema Complete Graph</strong> contains all used linked Properties</li>
<li>A <strong>Frozen Graph</strong> contains content-addressing identifiers (e.g. IPFS), all the way down</li>
</ul>
<p>These concepts are important when creating an implementation of a Store.</p>
<h2><a class="header" href="#valid-graphs" id="valid-graphs">Valid Graphs</a></h2>
<p>We refer to a Graph as Valid, if the following constraints are met:</p>
<ul>
<li><strong>The Datatypes are correctly used</strong>. The Graph does not contain Atoms where the Datatype of the Value does not match the Datatype of the Property of the Atom.</li>
<li><strong>The links work</strong>. All URLs used in the Graph (Subject, Property, Value) resolve correctly to the required Datatype.</li>
<li><strong>The Class Restrictions are met</strong>. If a Class sets required properties, these must be present in Resources that are instances of that Class.</li>
</ul>
<p>Making sure Graphs are Valid is of great importance to anyone creating, sharing or using Atomic Data.
Services should specify whether they check the validity of graphs.</p>
<h2><a class="header" href="#closed-graphs" id="closed-graphs">Closed Graphs</a></h2>
<p>A Graph is Closed, when the Resources of all URLs are present in the Graph.
In other words, if you were to fetch and download every single URL in a Graph, you would not have any more Atoms than before.
There are no more unfetched outgoing links.</p>
<p>Closed Graphs are <em>rarely</em> required in Atomic Data; it's often perfectly fine to have outgoing links that do not have been fetched.</p>
<h2><a class="header" href="#verified-graphs" id="verified-graphs">Verified Graphs</a></h2>
<p>When you are given some Atomic Graph by someone, you initially don't know for sure whether the Atoms themselves are actually created by the one controlling the subject URL.
Someone may have tempered with the data, or fabricated it.</p>
<p>The process of Verification can be done in two ways:</p>
<ol>
<li><strong>Request the subjects, and check if the atoms match</strong>.</li>
<li><strong>Verify the signatures of the Resources or Mutations</strong></li>
</ol>
<p>When one of these steps is taken, we say that the Graph is Verified.</p>
<h2><a class="header" href="#schema-complete-graphs" id="schema-complete-graphs">Schema Complete Graphs</a></h2>
<p>When a Graph has a set of Atoms, it might not possess all the information that is required to determine the datatype of each Atom.
When that is the case, we say the Graph is <em>Schema Complete</em>.</p>
<p>Having a Schema Complete Graph is essential for determining what the Datatype is of a Value.
Most implementations of Atomic Data will need Schema Completeness to create fitting views, or apply functional business logic.</p>
<p>Imagine some application (perhaps an app running inside a web-browser) that has only the following data:</p>
<pre><code class="language-ndjson">[&quot;https://example.com/john&quot;,&quot;https://example.com/birthDate&quot;,&quot;1991-01-20&quot;]
</code></pre>
<p>Now, by looking at this single Atom, we might assume that the Value is an ISO date,
but this type information is not known yet to the application.
This type information should be specified in the <code>example:birthDate</code> Property.
It is the responsibility of the application to make sure it possess the required Schema data.</p>
<p>We say a Graph is <em>Schema Complete</em> when it contains <em>at least</em> all the Property Classes that are used in the Property fields.</p>
<p>So let's add the missing Property: <code>https://example.com/birthDate</code></p>
<pre><code class="language-ndjson">[&quot;https://example.com/john&quot;,&quot;https://example.com/birthDate&quot;,&quot;1991-01-20&quot;]
[&quot;https://example.com/birthDate&quot;,&quot;https://atomicdata.dev/datatypes/Datatype&quot;,&quot;https://atomicdata.dev/datatypes/dateTime&quot;]
</code></pre>
<p>Now, since we've introduced yet another Property, we need to include that one as well:</p>
<pre><code class="language-ndjson">[&quot;https://example.com/john&quot;,&quot;https://example.com/birthDate&quot;,&quot;1991-01-20&quot;]
[&quot;https://example.com/birthDate&quot;,&quot;https://atomicdata.dev/datatypes/Datatype&quot;,&quot;https://atomicdata.dev/datatypes/dateTime&quot;]
[&quot;https://atomicdata.dev/datatypes/Datatype&quot;,&quot;https://atomicdata.dev/datatypes/Datatype&quot;,&quot;https://atomicdata.dev/datatypes/atomicURI&quot;]
</code></pre>
<p>Since all valid Atomic Data requires Property fields to resolve to Atomic Properties Classes, which are required to have an associated DataType...
We can safely say that the last atom in the example above (the one describing <code>https://atomicdata.dev/datatypes/Datatype</code>) will have to be pre
sent in all Schema Complete Atomic Graphs.</p>
<h2><a class="header" href="#frozen-graphs" id="frozen-graphs">Frozen Graphs</a></h2>
<p>A Frozen Graph consists only of resources with content-addressing identifiers as Subjects.
A <a href="https://flyingzumwalt.gitbooks.io/decentralized-web-primer/avenues-for-access/lessons/power-of-content-addressing.html">content-addressable</a> URL (such as an IPFS URL) refers to specific immutable content, that is absolutely certain not to change over time.
Due to its static nature, we call it <em>Frozen</em>.
As long as a graph contains links to HTTP Resources, it is not Frozen, since responses from that HTTP address might change over time.</p>
<p>Freezing a Graph, therefore, entails converting all resources to IFPS (or another content-addressable schema) Resources, and using only IPFS URLs.</p>
<p>Freezing a Graph has performance benefits for clients, since clients can easily verify if they already have (part of) the Graph locally, simply by comparing the URLs or Resources.
It also helps to make sure the content can be shared peer to peer</p>
<p>Note that <strong>Graphs with cyclical relations cannot be frozen</strong>, since every iteration that you'd try to freeze will change its references and therefore also its contents, and therefore also its content hash.</p>
<h1><a class="header" href="#tooling-for-atomic-data" id="tooling-for-atomic-data">Tooling for Atomic Data</a></h1>
<p>Because Atomic Data is very young, <strong>little tooling for Atomic Data exists</strong>.
Great tooling is required to make this a success.</p>
<h2><a class="header" href="#existing-tooling" id="existing-tooling">Existing tooling</a></h2>
<h3><a class="header" href="#atomic-cli" id="atomic-cli"><code>atomic-cli</code></a></h3>
<p>A tool for generating / querying Atomic Data from the command line.</p>
<pre><code class="language-sh"># Add a mapping, and store the Atomic Class locally
atomic map person https://example.com/person
# Create a new instance with that Class
atomic new person
name (required): John McLovin
age: 31
Created at: ipfs:Qwhp2fh3o8hfo8w7fhwo77w38ohw3o78fhw3ho78w3o837ho8fwh8o7fh37ho
# link to an Atomic Server where you can upload your stuff
# If you don't, your data exists locally and gets published to IPFS
atomic setup
# install ontologies and add their shortnames to bookmarks
atomic install https://atomicdata.dev/ontologies/meetings
# when no URL is given, use the Ontola repo's ontologies
atomic install meetings
</code></pre>
<p>MIT licensed <a href="%5Bhere%5D(https://github.com/joepio/atomic/cli)">repo here</a>.</p>
<h3><a class="header" href="#atomic-lib-rust" id="atomic-lib-rust"><code>atomic-lib</code> (Rust)</a></h3>
<p>Library that contains:</p>
<ul>
<li>An in-memory store</li>
<li>Parsing (AD3) / Serialization (AD3, JSON, more to come)</li>
<li>Path traversal</li>
<li>Basic validation</li>
</ul>
<p>MIT licensed <a href="%5Bhere%5D(https://github.com/joepio/atomic/lib)">repo here</a>.</p>
<h3><a class="header" href="#atomic-server" id="atomic-server"><code>atomic-server</code></a></h3>
<p>Server for hosting Atomic Data. Uses <code>atomic-lib</code>.</p>
<ul>
<li>Responds to requests for created Atomic Resources, makes atomic data available at their URL.</li>
<li>Manages data on disk.</li>
<li>Useful query options (e.g. Triple Pattern Fragments)</li>
<li>Browser-friendly HTML presentation, JSON serialization, AD3 serialization.</li>
</ul>
<p>MIT licensed <a href="%5Bhere%5D(https://github.com/joepio/atomic/server)">repo here</a>.</p>
<h2><a class="header" href="#some-ideas-for-tooling" id="some-ideas-for-tooling">Some ideas for tooling</a></h2>
<p>This document contains a set of ideas that would help achieve that success.</p>
<h2><a class="header" href="#atoml--vscode-extension" id="atoml--vscode-extension">ATOML / VSCode Extension</a></h2>
<p>Extending the TOML format to map it to Atomic Classes.
This will make editing .TOML files awesome by providing on-screen validation, autocompletion and documentation for fields.</p>
<h2><a class="header" href="#atomizer-data-importer-and-conversion-kit" id="atomizer-data-importer-and-conversion-kit">Atomizer (data importer and conversion kit)</a></h2>
<ul>
<li>Import data from some data source (CSV / SQL / JSON / RDF), fill in the gaps (mapping / IRI creation / datatypes) an create new Atoms</li>
<li>Perhaps a CLI, library, GUI or a combination of all of these</li>
</ul>
<h2><a class="header" href="#atomic-preview" id="atomic-preview">Atomic Preview</a></h2>
<ul>
<li>A simple (JS) widget that can be embedded anywhere, which converts an Atomic Graph into an HTML view.</li>
<li>Would be useful for documentation, and as a default view for Atomic Data.</li>
</ul>
<h2><a class="header" href="#atomic-js-javascript--typescript" id="atomic-js-javascript--typescript">Atomic-js (Javascript / Typescript)</a></h2>
<p>A JS compatible library, accessible as an NPM package is the most popular and developer friendly way to start.</p>
<p>Here's some pseudocode that indicates how it might be used:</p>
<pre><code class="language-js">import {createStore} from '@atomicdata';

const config = {
  // A URL to a TPF compatible endpoint where the data can be fetched
  tpfEndpoint: &quot;https://example.com/tpf&quot;,
  // A UTL to an Atomic Mutations endpoint where the client can subscribe to changes
  mutationsEndpoint: &quot;https://example.com/mutations&quot;,
  // A UTL to an Atomic Suggestions endpoint where the client can send suggested state changes
  sugestionsEndpoint: &quot;https://example.com/suggestions&quot;,
};

const store = createStore(config); // Initializes the store

// The `classInitializer` function takes an Atomic Class URI as its argument
// fetches the Class, its Properties and the DataTypes
// and returns a function that let's you create instances of that class
const personBuilder = await store.classInitializer(&quot;https://example.com/classes/Person&quot;);

// Create an instance of the Person Class
// An Atomic Suggestion is sent to the
const alice = await personBuilder({
  // The Subject field is optional, but recommended if you want to control its URL.
  // Otherwise, the Server will pick something
  subject: &quot;https://example.com/alice&quot;,
  // The IDE is aware of the existing keys and their acceptable values,
  // because a conversion from Atomic Classes and Properties
  // to typescript interfaces can be made automatically
  firstName: &quot;Alice&quot;,
  lastName: &quot;Anderson&quot;,
  bestFriend: &quot;https://example.com/Bob&quot;,
  birthDate: new Date(&quot;1991-01-20&quot;),
  // Since the URL in the key below can be fetched, and has a Property + Datatype, the IDE + the compiler can determine that 'true' is an acceptable type.
  &quot;https://example.com/someOtherProperty&quot;: true,
})

console.log(person.subject) //=&gt; Should return a newly created identifier, https://example.com/alice

// Checks the store for the subject, and returns it.
// If the subject does not exists locally, it will fetch it first using the `tpfEndpoint`.
const alice = await store.get(&quot;https://example.com/alice&quot;)

// Because of the keys in Atomic Properties, we can use this dot syntax to traverse the graph and get a value
console.log(await alice.path(&quot;bestFriend.firstName&quot;)).value(); // =&gt; &quot;Bob&quot;
// What should happen here?
console.log(await alice.bestFriend); // =&gt; {...}

// It's also possible to convert a resource to a native JS object.
// By specifying the depth, nested resources will be fetched as well.
const aliceJS = await store.get(&quot;https://example.com/alice&quot;).toJS(depth: 2)

console.log(aliceJS.bestFriend) // =&gt; { name: Bob, birthdate: Date(1991-01-20)}

</code></pre>
<p>I think a Developer Experience similar to the one above is essential for getting people to create linked data.
It should be incredibly easy, and this is what enables that.
However, realizing a library + IDE support as shown above is hard at the least, perhaps even impossible.
Theoretically, the information is accessible - but I'm not sure whether the IDE and the JS context (e.g. the Typescript compiler) can successfully see which shape is being returned by the <code>classInitializer</code> function.</p>
<h2><a class="header" href="#atomic-browser" id="atomic-browser">Atomic Browser</a></h2>
<p>A web-browser application that enables viewing, browsing, navigating Atomic Data.</p>
<h1><a class="header" href="#get-involved" id="get-involved">Get involved</a></h1>
<p>Atomic Data is an open specification, and that means that you're very welcome to share your thoughts and help make this standard as good as possible.</p>
<p>Things you can do:</p>
<ul>
<li>Clone the <a href="https://github.com/ontola/atomic-data/">Book Repo</a> and read some of the inline comments, which might help start some discussions</li>
<li>Drop an <a href="https://github.com/ontola/atomic-data/issues">issue on Github</a> to share your suggestions or criticism</li>
<li>Join the <a href="https://discord.gg/ZspQv8">Discord server</a> for voice / text chat</li>
<li>Support our suggested <a href="https://www.w3.org/community/blog/2020/06/22/proposed-group-atomic-data-community-group/">W3C Community Group</a></li>
</ul>
<h2><a class="header" href="#authors" id="authors">Authors:</a></h2>
<ul>
<li>Joep Meindertsma (<a href="https://github.com/joepio/">joepio</a> from <a href="https://ontola.io/">Ontola.io</a>)</li>
</ul>
<h2><a class="header" href="#special-thanks-to" id="special-thanks-to">Special thanks to:</a></h2>
<ul>
<li>Thom van Kalkeren (who came up with many great ideas on how to work with RDF, such as <a href="https://github.com/ontola/hextuples">HexTuples</a> and <a href="https://github.com/ontola/linked-delta">linked-delta</a>)</li>
<li>Tim Berners-Lee (for everything he did for linked data and the web)</li>
<li>Ruben Verborgh (for doing great work with RDF, such as the TPF spec)</li>
<li>All the other people who worked on the RDF specification</li>
<li>Pat McBennett (lots of valuable feedback on initial Atomic Data docs)</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-121994595-2', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
